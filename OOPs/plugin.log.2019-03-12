2019-03-12 18:57:51,954 INFO  Loading Baseframework Plugin
2019-03-12 18:57:51,973 INFO  Initializing the platform to load the Menu - HandsOn
2019-03-12 18:57:51,977 INFO  Loading the Menu - HandsOn
2019-03-12 18:57:51,984 INFO  Successfully loaded the Menu - HandsOn
2019-03-12 18:59:08,034 INFO  Loading Programming Assignment Plugin
2019-03-12 18:59:08,433 INFO  Setting request parameters for VerifySolution
2019-03-12 18:59:08,434 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 18:59:08,439 INFO  Starting to parse the user solution
2019-03-12 18:59:08,440 INFO  Displaying user solution
2019-03-12 18:59:08,547 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-27\r\n'''\r\nCreated on Mar 8, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#This class represents ThemePark\r\nclass ThemePark:\r\n    #dict_of_games contains the game name as key, \r\n    #price/ride and points that can be earned by customer in a list as value\r\n    dict_of_games={\"Game1\":[35.5,5], \"Game2\":[40.0,6],\r\n                   \"Game3\":[120.0,10], \"Game4\":[60.0,7],\"Game5\":[25.0,4]}\r\n    @staticmethod\r\n    def validate_game(game_input):\r\n        if game_input in ThemePark.dict_of_games:\r\n            return True\r\n        return False\r\n        #Remove pass and write the logic here\r\n        #If game_input is present in ThemePark, return true. Else, return false.\r\n    @staticmethod\r\n    def get_points(game_input):\r\n        for key,value in ThemePark.dict_of_games.items():\r\n            if(game_input==key):\r\n                return value[1]\r\n        #Remove pass and write the logic here\r\n        #Return the points that can be earned for the given game_input.\r\n    @staticmethod\r\n    def get_amount(game_input):\r\n       for key,value in ThemePark.dict_of_games.items():\r\n            if(game_input==key):\r\n                return value[0]\r\n        #Remove pass and write the logic here\r\n        #Return the price/ride for the given game_input\r\n\r\n#This class represents ticket\r\nclass Ticket:\r\n    __ticket_count=200\r\n    def __init__(self):\r\n        self.__ticket_id=None\r\n        self.__ticket_amount=0\r\n    def generate_ticket_id(self):\r\n        Ticket.__ticket_count+=1\r\n        self.__ticket_id=Ticket.__ticket_count\r\n        #Remove pass and write the logic here\r\n        #Auto-generate ticket_id starting from 201\r\n    def calculate_amount(self, list_of_games):\r\n        for i in list_of_games:\r\n            if ThemePark.validate_game(i):\r\n                self.__ticket_amount += ThemePark.dict_of_games[i][0]\r\n            else:\r\n                return False\r\n        return True \r\n        #Remove pass and write the logic here\r\n        '''Validate the games in the list_of_games.\r\n        If all games are valid, calculate total \r\n        ticket amount and assign it to attribute, \r\n        ticket_amount and return true. Else, return false'''\r\n    def get_ticket_id(self):\r\n        return self.__ticket_id\r\n    def get_ticket_amount(self):\r\n        return self.__ticket_amount\r\n\r\nclass Customer:\r\n    def __init__(self,name,list_of_games):\r\n        self.__name = name\r\n        self.__list_of_games = list_of_games \r\n        self.__ticket = Ticket()\r\n        self.__points_earned = 0\r\n        self.__food_coupon = 'No'\r\n\r\n    def play_game(self):\r\n        self.__points_earned = 0\r\n        for i in self.__list_of_games:\r\n            self.__points_earned += ThemePark.get_points(i)\r\n        if(\"Game3\" in self.__list_of_games):\r\n            self.__list_of_games.append(\"Game2\")\r\n            self.__points_earned += ThemePark.get_points(\"Game2\")    \r\n    \r\n    def update_food_coupon(self):\r\n        self.play_game()\r\n        if(\"Game4\" in self.__list_of_games and self.__points_earned > 15):\r\n            self.__food_coupon = \"Yes\"\r\n    \r\n    def book_ticket(self):\r\n        if(self.__ticket.calculate_amount(self.__list_of_games)):\r\n            self.__ticket.generate_ticket_id()\r\n            self.play_game()\r\n            self.update_food_coupon()\r\n        else:\r\n            return False\r\n        return True\r\n    \r\n    def get_name(self):\r\n        return self.__name\r\n\r\n    def get_list_of_games(self):\r\n        return self.__list_of_games\r\n\r\n    def get_ticket(self):\r\n        return self.__ticket\r\n\r\n    def get_points_earned(self):\r\n        return self.__points_earned\r\n\r\n    def get_food_coupon(self):\r\n        return self.__food_coupon\r\n    #Remove pass and implement class Customer here\r\n\r\n'''Represent customers and display all details of the customer, if he is able to book the ticket and play the game. Else, display appropriate error message '''\r\n","asgnmtId":"27","SolutionFileName":"Assign27.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 18:59:08,549 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 18:59:08,550 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 18:59:08,550 INFO  Invoking the service to verify the user solution
2019-03-12 18:59:08,550 INFO  Time before invoking service:Tue Mar 12 18:59:08 IST 2019
2019-03-12 18:59:08,551 INFO  Initialising service address for VerifySolution
2019-03-12 18:59:08,552 INFO  Time before invoking service In SUPER:Tue Mar 12 18:59:08 IST 2019
2019-03-12 18:59:09,893 INFO  Time after invoking service In SUPER:Tue Mar 12 18:59:09 IST 2019
2019-03-12 18:59:09,894 INFO  Service responded successfully with required details
2019-03-12 18:59:09,894 INFO  Time after invoking service:Tue Mar 12 18:59:09 IST 2019
2019-03-12 18:59:09,895 INFO  User solution successfully verified
2019-03-12 18:59:09,895 INFO  Processing the response from verify service
2019-03-12 18:59:09,905 INFO  Starting to parse JSON response
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,909 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 18:59:09,913 INFO  Successfully parsed JSON response
2019-03-12 18:59:09,914 INFO  In the process of generating verify response in HTML
2019-03-12 18:59:10,205 INFO  Successfully generated verify response in HTML
2019-03-12 18:59:10,206 INFO  Successfully processed the response from service
2019-03-12 19:00:14,948 INFO  Setting request parameters for VerifySolution
2019-03-12 19:00:14,948 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:00:14,948 INFO  Starting to parse the user solution
2019-03-12 19:00:14,949 INFO  Displaying user solution
2019-03-12 19:00:15,006 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-27\r\n'''\r\nCreated on Mar 8, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#This class represents ThemePark\r\nclass ThemePark:\r\n    #dict_of_games contains the game name as key, \r\n    #price/ride and points that can be earned by customer in a list as value\r\n    dict_of_games={\"Game1\":[35.5,5], \"Game2\":[40.0,6],\r\n                   \"Game3\":[120.0,10], \"Game4\":[60.0,7],\"Game5\":[25.0,4]}\r\n    @staticmethod\r\n    def validate_game(game_input):\r\n        if game_input in ThemePark.dict_of_games:\r\n            return True\r\n        return False\r\n        #Remove pass and write the logic here\r\n        #If game_input is present in ThemePark, return true. Else, return false.\r\n    @staticmethod\r\n    def get_points(game_input):\r\n        for key,value in ThemePark.dict_of_games.items():\r\n            if(game_input==key):\r\n                return value[1]\r\n        #Remove pass and write the logic here\r\n        #Return the points that can be earned for the given game_input.\r\n    @staticmethod\r\n    def get_amount(game_input):\r\n       for key,value in ThemePark.dict_of_games.items():\r\n            if(game_input==key):\r\n                return value[0]\r\n        #Remove pass and write the logic here\r\n        #Return the price/ride for the given game_input\r\n\r\n#This class represents ticket\r\nclass Ticket:\r\n    __ticket_count=200\r\n    def __init__(self):\r\n        self.__ticket_id=None\r\n        self.__ticket_amount=0\r\n    def generate_ticket_id(self):\r\n        Ticket.__ticket_count+=1\r\n        self.__ticket_id=Ticket.__ticket_count\r\n        #Remove pass and write the logic here\r\n        #Auto-generate ticket_id starting from 201\r\n    def calculate_amount(self, list_of_games):\r\n        for i in list_of_games:\r\n            if ThemePark.validate_game(i):\r\n                self.__ticket_amount += ThemePark.dict_of_games[i][0]\r\n            else:\r\n                return False\r\n        return True \r\n        #Remove pass and write the logic here\r\n        '''Validate the games in the list_of_games.\r\n        If all games are valid, calculate total \r\n        ticket amount and assign it to attribute, \r\n        ticket_amount and return true. Else, return false'''\r\n    def get_ticket_id(self):\r\n        return self.__ticket_id\r\n    def get_ticket_amount(self):\r\n        return self.__ticket_amount\r\n\r\nclass Customer:\r\n    def __init__(self,name,list_of_games):\r\n        self.__name = name\r\n        self.__list_of_games = list_of_games \r\n        self.__ticket = Ticket()\r\n        self.__points_earned = 0\r\n        self.__food_coupon = 'No'\r\n\r\n    def play_game(self):\r\n        self.__points_earned = 0\r\n        for i in self.__list_of_games:\r\n            self.__points_earned += ThemePark.get_points(i)\r\n        if(\"Game3\" in self.__list_of_games):\r\n            self.__list_of_games.append(\"Game2\")\r\n            self.__points_earned += ThemePark.get_points(\"Game2\")    \r\n    \r\n    def update_food_coupon(self):\r\n        self.play_game()\r\n        if(\"Game4\" in self.__list_of_games and self.__points_earned > 15):\r\n            self.__food_coupon = \"Yes\"\r\n    \r\n    def book_ticket(self):\r\n        if(self.__ticket.calculate_amount(self.__list_of_games)):\r\n            self.__ticket.generate_ticket_id()\r\n            self.play_game()\r\n            self.update_food_coupon()\r\n        else:\r\n            return False\r\n        return True\r\n    \r\n    def get_name(self):\r\n        return self.__name\r\n\r\n    def get_list_of_games(self):\r\n        return self.__list_of_games\r\n\r\n    def get_ticket(self):\r\n        return self.__ticket\r\n\r\n    def get_points_earned(self):\r\n        return self.__points_earned\r\n\r\n    def get_food_coupon(self):\r\n        return self.__food_coupon\r\n    #Remove pass and implement class Customer here\r\n\r\n'''Represent customers and display all details of the customer, if he is able to book the ticket and play the game. Else, display appropriate error message '''\r\n","asgnmtId":"27","SolutionFileName":"Assign27.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:00:15,006 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:00:15,006 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:00:15,006 INFO  Invoking the service to verify the user solution
2019-03-12 19:00:15,007 INFO  Time before invoking service:Tue Mar 12 19:00:15 IST 2019
2019-03-12 19:00:15,007 INFO  Initialising service address for VerifySolution
2019-03-12 19:00:15,008 INFO  Time before invoking service In SUPER:Tue Mar 12 19:00:15 IST 2019
2019-03-12 19:00:16,408 INFO  Time after invoking service In SUPER:Tue Mar 12 19:00:16 IST 2019
2019-03-12 19:00:16,409 INFO  Service responded successfully with required details
2019-03-12 19:00:16,409 INFO  Time after invoking service:Tue Mar 12 19:00:16 IST 2019
2019-03-12 19:00:16,409 INFO  User solution successfully verified
2019-03-12 19:00:16,410 INFO  Processing the response from verify service
2019-03-12 19:00:16,412 INFO  Starting to parse JSON response
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,414 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:00:16,415 INFO  Successfully parsed JSON response
2019-03-12 19:00:16,416 INFO  In the process of generating verify response in HTML
2019-03-12 19:00:16,516 INFO  Successfully generated verify response in HTML
2019-03-12 19:00:16,516 INFO  Successfully processed the response from service
2019-03-12 19:01:01,588 INFO  Setting request parameters for VerifySolution
2019-03-12 19:01:01,588 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:01:01,588 INFO  Starting to parse the user solution
2019-03-12 19:01:01,589 INFO  Displaying user solution
2019-03-12 19:01:01,635 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-30\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nclass Customer:\r\n    \r\n    def __init__(self,customer_name,quantity):\r\n        self.__customer_name=customer_name\r\n        self.__quantity=quantity\r\n\r\n    def validate_quantity(self):\r\n        if(self.__quantity in range (1,6)):\r\n            return True\r\n        return False\r\n\r\n    def get_customer_name(self):\r\n        return self.__customer_name\r\n\r\n\r\n    def get_quantity(self):\r\n        return self.__quantity\r\n    \r\nclass Pizzaservice:\r\n    counter = 100\r\n    def __init__(self,customer,pizza_type,additional_topping):\r\n        self.__service_id =None\r\n        self.__customer = customer\r\n        self.__pizza_type = pizza_type\r\n        self.__additional_topping = additional_topping\r\n        self.pizza_cost = None\r\n\r\n\r\n    def validate_pizza_type(self):\r\n        if(self.get_pizza_type().lower() in [\"small\",\"medium\"]):\r\n            return True\r\n        return False\r\n    \r\n    def calculate_pizza_cost(self):\r\n        if(self.validate_pizza_type() and self.__customer.validate_quantity()):\r\n            if(self.__pizza_type.lower() == \"small\"):\r\n                if(self.__additional_topping):\r\n                    price = self.__customer.get_quantity()*(150+35)\r\n                else:\r\n                    price = self.__customer.get_quantity()*(150)\r\n                Pizzaservice.counter+=1\r\n                self.__service_id = (self.get_pizza_type()[0]+\r\n                str(Pizzaservice.counter))\r\n            elif(self.__pizza_type.lower() == \"medium\"):\r\n                if(self.__additional_topping):\r\n                    price = self.__customer.get_quantity()*(200+50)\r\n                else:\r\n                    price = self.__customer.get_quantity()*(200)\r\n                Pizzaservice.counter+=1\r\n                self.__service_id = (self.get_pizza_type()[0]+\r\n                                     str(Pizzaservice.counter))\r\n            self.pizza_cost = price\r\n\r\n        else:\r\n            self.pizza_cost = -1\r\n    def get_service_id(self):\r\n        return self.__service_id\r\n\r\n\r\n    def get_customer(self):\r\n        return self.__customer\r\n\r\n\r\n    def get_pizza_type(self):\r\n        return self.__pizza_type\r\n\r\n\r\n    def get_additional_topping(self):\r\n        return self.__additional_topping\r\n\r\nclass Doordelivery(Pizzaservice):\r\n    def __init__(self,customer,pizza_type,additional_topping,distance_in_kms):\r\n        super().__init__(customer, pizza_type, additional_topping)\r\n        self.__delivery_charge = None\r\n        self.__distance_in_kms = distance_in_kms\r\n    \r\n    def validate_distance_in_kms(self):\r\n        if(self.get_distance_in_kms() in range(1,11)):\r\n            return True\r\n        return False\r\n    \r\n    \r\n    def calculate_pizza_cost(self):\r\n        if(self.validate_distance_in_kms()):\r\n            super().calculate_pizza_cost()\r\n            if(self.pizza_cost != -1):\r\n                if(self.get_distance_in_kms() <=5):\r\n                    self.__delivery_charge = self.get_distance_in_kms()*5\r\n                elif(self.get_distance_in_kms() >5):\r\n                    self.__delivery_charge =(((self.get_distance_in_kms()-5)*7)\r\n                                             +25)\r\n                self.pizza_cost += self.get_delivery_charge()\r\n        else:\r\n            self.pizza_cost = -1\r\n                 \r\n    def get_delivery_charge(self):\r\n        return self.__delivery_charge\r\n\r\n\r\n    def get_distance_in_kms(self):\r\n        return self.__distance_in_kms\r\n    \r\nc1=Customer('Raja' , 1)\r\nd1=Doordelivery(c1,\"small\",False,1)\r\na=d1.calculate_pizza_cost()\r\n","asgnmtId":"30","SolutionFileName":"Assign30.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:01:01,636 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:01:01,636 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:01:01,636 INFO  Invoking the service to verify the user solution
2019-03-12 19:01:01,636 INFO  Time before invoking service:Tue Mar 12 19:01:01 IST 2019
2019-03-12 19:01:01,636 INFO  Initialising service address for VerifySolution
2019-03-12 19:01:01,637 INFO  Time before invoking service In SUPER:Tue Mar 12 19:01:01 IST 2019
2019-03-12 19:01:02,982 INFO  Time after invoking service In SUPER:Tue Mar 12 19:01:02 IST 2019
2019-03-12 19:01:02,983 INFO  Service responded successfully with required details
2019-03-12 19:01:02,983 INFO  Time after invoking service:Tue Mar 12 19:01:02 IST 2019
2019-03-12 19:01:02,983 INFO  User solution successfully verified
2019-03-12 19:01:02,984 INFO  Processing the response from verify service
2019-03-12 19:01:02,987 INFO  Starting to parse JSON response
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,989 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,990 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,990 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:01:02,992 INFO  Successfully parsed JSON response
2019-03-12 19:01:02,992 INFO  In the process of generating verify response in HTML
2019-03-12 19:01:03,079 INFO  Successfully generated verify response in HTML
2019-03-12 19:01:03,080 INFO  Successfully processed the response from service
2019-03-12 19:02:15,189 INFO  Setting request parameters for VerifySolution
2019-03-12 19:02:15,189 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:02:15,189 INFO  Starting to parse the user solution
2019-03-12 19:02:15,190 INFO  Displaying user solution
2019-03-12 19:02:15,300 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading < self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter+=1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type() and Logistics.validate_meter_reading(self)):\r\n            return True\r\n        return False # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(Logistics.validate_meter_reading()):\r\n                Logistics.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:02:15,301 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:02:15,301 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:02:15,301 INFO  Invoking the service to verify the user solution
2019-03-12 19:02:15,302 INFO  Time before invoking service:Tue Mar 12 19:02:15 IST 2019
2019-03-12 19:02:15,302 INFO  Initialising service address for VerifySolution
2019-03-12 19:02:15,303 INFO  Time before invoking service In SUPER:Tue Mar 12 19:02:15 IST 2019
2019-03-12 19:02:17,014 INFO  Time after invoking service In SUPER:Tue Mar 12 19:02:17 IST 2019
2019-03-12 19:02:17,015 INFO  Service responded successfully with required details
2019-03-12 19:02:17,015 INFO  Time after invoking service:Tue Mar 12 19:02:17 IST 2019
2019-03-12 19:02:17,015 INFO  User solution successfully verified
2019-03-12 19:02:17,016 INFO  Processing the response from verify service
2019-03-12 19:02:17,018 INFO  Starting to parse JSON response
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,020 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:02:17,021 INFO  Successfully parsed JSON response
2019-03-12 19:02:17,022 INFO  In the process of generating verify response in HTML
2019-03-12 19:02:17,108 INFO  Successfully generated verify response in HTML
2019-03-12 19:02:17,108 INFO  Successfully processed the response from service
2019-03-12 19:06:47,831 INFO  Setting request parameters for VerifySolution
2019-03-12 19:06:47,831 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:06:47,831 INFO  Starting to parse the user solution
2019-03-12 19:06:47,838 INFO  Displaying user solution
2019-03-12 19:06:47,907 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#OOPR-Assgn-31\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        pass # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        pass # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(validate_carrier_type()):\r\n            if(validate_meter_reading()):\r\n                generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=self.__carrier_dict[__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:06:47,909 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:06:47,910 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:06:47,910 INFO  Invoking the service to verify the user solution
2019-03-12 19:06:47,910 INFO  Time before invoking service:Tue Mar 12 19:06:47 IST 2019
2019-03-12 19:06:47,910 INFO  Initialising service address for VerifySolution
2019-03-12 19:06:47,911 INFO  Time before invoking service In SUPER:Tue Mar 12 19:06:47 IST 2019
2019-03-12 19:06:49,582 INFO  Time after invoking service In SUPER:Tue Mar 12 19:06:49 IST 2019
2019-03-12 19:06:49,582 INFO  Service responded successfully with required details
2019-03-12 19:06:49,582 INFO  Time after invoking service:Tue Mar 12 19:06:49 IST 2019
2019-03-12 19:06:49,583 INFO  User solution successfully verified
2019-03-12 19:06:49,583 INFO  Processing the response from verify service
2019-03-12 19:06:49,594 INFO  Starting to parse JSON response
2019-03-12 19:06:49,597 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,597 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,597 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,597 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,597 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,597 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,598 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,598 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,598 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,598 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:06:49,599 INFO  Successfully parsed JSON response
2019-03-12 19:06:49,601 INFO  In the process of generating verify response in HTML
2019-03-12 19:06:49,680 INFO  Successfully generated verify response in HTML
2019-03-12 19:06:49,680 INFO  Successfully processed the response from service
2019-03-12 19:07:09,252 INFO  Setting request parameters for VerifySolution
2019-03-12 19:07:09,252 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:07:09,252 INFO  Starting to parse the user solution
2019-03-12 19:07:09,252 INFO  Displaying user solution
2019-03-12 19:07:09,304 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter+=1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type() and Logistics.validate_meter_reading(self)):\r\n            Logistics.generate_consumer_id(self)\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(Logistics.validate_meter_reading()):\r\n                Logistics.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:07:09,304 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:07:09,304 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:07:09,304 INFO  Invoking the service to verify the user solution
2019-03-12 19:07:09,305 INFO  Time before invoking service:Tue Mar 12 19:07:09 IST 2019
2019-03-12 19:07:09,305 INFO  Initialising service address for VerifySolution
2019-03-12 19:07:09,306 INFO  Time before invoking service In SUPER:Tue Mar 12 19:07:09 IST 2019
2019-03-12 19:07:11,025 INFO  Time after invoking service In SUPER:Tue Mar 12 19:07:11 IST 2019
2019-03-12 19:07:11,025 INFO  Service responded successfully with required details
2019-03-12 19:07:11,026 INFO  Time after invoking service:Tue Mar 12 19:07:11 IST 2019
2019-03-12 19:07:11,026 INFO  User solution successfully verified
2019-03-12 19:07:11,026 INFO  Processing the response from verify service
2019-03-12 19:07:11,029 INFO  Starting to parse JSON response
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,031 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:07:11,032 INFO  Successfully parsed JSON response
2019-03-12 19:07:11,034 INFO  In the process of generating verify response in HTML
2019-03-12 19:07:11,102 INFO  Successfully generated verify response in HTML
2019-03-12 19:07:11,103 INFO  Successfully processed the response from service
2019-03-12 19:20:23,100 INFO  Setting request parameters for VerifySolution
2019-03-12 19:20:23,100 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:20:23,100 INFO  Starting to parse the user solution
2019-03-12 19:20:23,100 INFO  Displaying user solution
2019-03-12 19:20:23,169 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter+=1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(Logistics.validate_meter_reading()):\r\n                Logistics.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:20:23,170 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:20:23,170 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:20:23,170 INFO  Invoking the service to verify the user solution
2019-03-12 19:20:23,171 INFO  Time before invoking service:Tue Mar 12 19:20:23 IST 2019
2019-03-12 19:20:23,171 INFO  Initialising service address for VerifySolution
2019-03-12 19:20:23,171 INFO  Time before invoking service In SUPER:Tue Mar 12 19:20:23 IST 2019
2019-03-12 19:20:24,708 INFO  Time after invoking service In SUPER:Tue Mar 12 19:20:24 IST 2019
2019-03-12 19:20:24,708 INFO  Service responded successfully with required details
2019-03-12 19:20:24,708 INFO  Time after invoking service:Tue Mar 12 19:20:24 IST 2019
2019-03-12 19:20:24,708 INFO  User solution successfully verified
2019-03-12 19:20:24,709 INFO  Processing the response from verify service
2019-03-12 19:20:24,717 INFO  Starting to parse JSON response
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,719 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:20:24,721 INFO  Successfully parsed JSON response
2019-03-12 19:20:24,722 INFO  In the process of generating verify response in HTML
2019-03-12 19:20:24,806 INFO  Successfully generated verify response in HTML
2019-03-12 19:20:24,806 INFO  Successfully processed the response from service
2019-03-12 19:23:33,100 INFO  Setting request parameters for VerifySolution
2019-03-12 19:23:33,101 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:23:33,101 INFO  Starting to parse the user solution
2019-03-12 19:23:33,103 INFO  Displaying user solution
2019-03-12 19:23:33,157 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter+=1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:23:33,158 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:23:33,158 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:23:33,158 INFO  Invoking the service to verify the user solution
2019-03-12 19:23:33,158 INFO  Time before invoking service:Tue Mar 12 19:23:33 IST 2019
2019-03-12 19:23:33,158 INFO  Initialising service address for VerifySolution
2019-03-12 19:23:33,159 INFO  Time before invoking service In SUPER:Tue Mar 12 19:23:33 IST 2019
2019-03-12 19:23:34,581 INFO  Time after invoking service In SUPER:Tue Mar 12 19:23:34 IST 2019
2019-03-12 19:23:34,581 INFO  Service responded successfully with required details
2019-03-12 19:23:34,581 INFO  Time after invoking service:Tue Mar 12 19:23:34 IST 2019
2019-03-12 19:23:34,581 INFO  User solution successfully verified
2019-03-12 19:23:34,581 INFO  Processing the response from verify service
2019-03-12 19:23:34,584 INFO  Starting to parse JSON response
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,586 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:23:34,587 INFO  Successfully parsed JSON response
2019-03-12 19:23:34,588 INFO  In the process of generating verify response in HTML
2019-03-12 19:23:34,668 INFO  Successfully generated verify response in HTML
2019-03-12 19:23:34,668 INFO  Successfully processed the response from service
2019-03-12 19:24:44,359 INFO  Setting request parameters for VerifySolution
2019-03-12 19:24:44,359 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:24:44,360 INFO  Starting to parse the user solution
2019-03-12 19:24:44,360 INFO  Displaying user solution
2019-03-12 19:24:44,452 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter+=1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:24:44,453 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:24:44,454 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:24:44,454 INFO  Invoking the service to verify the user solution
2019-03-12 19:24:44,454 INFO  Time before invoking service:Tue Mar 12 19:24:44 IST 2019
2019-03-12 19:24:44,454 INFO  Initialising service address for VerifySolution
2019-03-12 19:24:44,455 INFO  Time before invoking service In SUPER:Tue Mar 12 19:24:44 IST 2019
2019-03-12 19:24:46,029 INFO  Time after invoking service In SUPER:Tue Mar 12 19:24:46 IST 2019
2019-03-12 19:24:46,030 INFO  Service responded successfully with required details
2019-03-12 19:24:46,030 INFO  Time after invoking service:Tue Mar 12 19:24:46 IST 2019
2019-03-12 19:24:46,030 INFO  User solution successfully verified
2019-03-12 19:24:46,031 INFO  Processing the response from verify service
2019-03-12 19:24:46,037 INFO  Starting to parse JSON response
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,038 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:24:46,040 INFO  Successfully parsed JSON response
2019-03-12 19:24:46,041 INFO  In the process of generating verify response in HTML
2019-03-12 19:24:46,121 INFO  Successfully generated verify response in HTML
2019-03-12 19:24:46,127 INFO  Successfully processed the response from service
2019-03-12 19:25:51,995 INFO  Setting request parameters for VerifySolution
2019-03-12 19:25:51,995 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:25:51,995 INFO  Starting to parse the user solution
2019-03-12 19:25:51,996 INFO  Displaying user solution
2019-03-12 19:25:52,058 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter += 1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:25:52,059 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:25:52,059 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:25:52,059 INFO  Invoking the service to verify the user solution
2019-03-12 19:25:52,060 INFO  Time before invoking service:Tue Mar 12 19:25:52 IST 2019
2019-03-12 19:25:52,060 INFO  Initialising service address for VerifySolution
2019-03-12 19:25:52,060 INFO  Time before invoking service In SUPER:Tue Mar 12 19:25:52 IST 2019
2019-03-12 19:25:53,582 INFO  Time after invoking service In SUPER:Tue Mar 12 19:25:53 IST 2019
2019-03-12 19:25:53,583 INFO  Service responded successfully with required details
2019-03-12 19:25:53,583 INFO  Time after invoking service:Tue Mar 12 19:25:53 IST 2019
2019-03-12 19:25:53,583 INFO  User solution successfully verified
2019-03-12 19:25:53,583 INFO  Processing the response from verify service
2019-03-12 19:25:53,586 INFO  Starting to parse JSON response
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,588 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:25:53,590 INFO  Successfully parsed JSON response
2019-03-12 19:25:53,591 INFO  In the process of generating verify response in HTML
2019-03-12 19:25:53,664 INFO  Successfully generated verify response in HTML
2019-03-12 19:25:53,665 INFO  Successfully processed the response from service
2019-03-12 19:26:49,997 INFO  Setting request parameters for VerifySolution
2019-03-12 19:26:49,997 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:26:49,997 INFO  Starting to parse the user solution
2019-03-12 19:26:49,997 INFO  Displaying user solution
2019-03-12 19:26:50,042 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=0\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter += 1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:26:50,043 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:26:50,043 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:26:50,043 INFO  Invoking the service to verify the user solution
2019-03-12 19:26:50,044 INFO  Time before invoking service:Tue Mar 12 19:26:50 IST 2019
2019-03-12 19:26:50,044 INFO  Initialising service address for VerifySolution
2019-03-12 19:26:50,044 INFO  Time before invoking service In SUPER:Tue Mar 12 19:26:50 IST 2019
2019-03-12 19:26:51,506 INFO  Time after invoking service In SUPER:Tue Mar 12 19:26:51 IST 2019
2019-03-12 19:26:51,507 INFO  Service responded successfully with required details
2019-03-12 19:26:51,507 INFO  Time after invoking service:Tue Mar 12 19:26:51 IST 2019
2019-03-12 19:26:51,507 INFO  User solution successfully verified
2019-03-12 19:26:51,508 INFO  Processing the response from verify service
2019-03-12 19:26:51,511 INFO  Starting to parse JSON response
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,512 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:26:51,513 INFO  Successfully parsed JSON response
2019-03-12 19:26:51,514 INFO  In the process of generating verify response in HTML
2019-03-12 19:26:51,575 INFO  Successfully generated verify response in HTML
2019-03-12 19:26:51,575 INFO  Successfully processed the response from service
2019-03-12 19:27:07,349 INFO  Setting request parameters for VerifySolution
2019-03-12 19:27:07,349 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:27:07,349 INFO  Starting to parse the user solution
2019-03-12 19:27:07,350 INFO  Displaying user solution
2019-03-12 19:27:07,397 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=0\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter += 1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:27:07,398 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:27:07,398 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:27:07,398 INFO  Invoking the service to verify the user solution
2019-03-12 19:27:07,399 INFO  Time before invoking service:Tue Mar 12 19:27:07 IST 2019
2019-03-12 19:27:07,399 INFO  Initialising service address for VerifySolution
2019-03-12 19:27:07,399 INFO  Time before invoking service In SUPER:Tue Mar 12 19:27:07 IST 2019
2019-03-12 19:27:08,959 INFO  Time after invoking service In SUPER:Tue Mar 12 19:27:08 IST 2019
2019-03-12 19:27:08,959 INFO  Service responded successfully with required details
2019-03-12 19:27:08,960 INFO  Time after invoking service:Tue Mar 12 19:27:08 IST 2019
2019-03-12 19:27:08,960 INFO  User solution successfully verified
2019-03-12 19:27:08,960 INFO  Processing the response from verify service
2019-03-12 19:27:08,962 INFO  Starting to parse JSON response
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,963 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,964 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,964 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:08,965 INFO  Successfully parsed JSON response
2019-03-12 19:27:08,967 INFO  In the process of generating verify response in HTML
2019-03-12 19:27:09,038 INFO  Successfully generated verify response in HTML
2019-03-12 19:27:09,038 INFO  Successfully processed the response from service
2019-03-12 19:27:53,602 INFO  Setting request parameters for VerifySolution
2019-03-12 19:27:53,602 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:27:53,602 INFO  Starting to parse the user solution
2019-03-12 19:27:53,603 INFO  Displaying user solution
2019-03-12 19:27:53,669 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:27:53,670 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:27:53,670 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:27:53,670 INFO  Invoking the service to verify the user solution
2019-03-12 19:27:53,671 INFO  Time before invoking service:Tue Mar 12 19:27:53 IST 2019
2019-03-12 19:27:53,671 INFO  Initialising service address for VerifySolution
2019-03-12 19:27:53,672 INFO  Time before invoking service In SUPER:Tue Mar 12 19:27:53 IST 2019
2019-03-12 19:27:55,140 INFO  Time after invoking service In SUPER:Tue Mar 12 19:27:55 IST 2019
2019-03-12 19:27:55,141 INFO  Service responded successfully with required details
2019-03-12 19:27:55,141 INFO  Time after invoking service:Tue Mar 12 19:27:55 IST 2019
2019-03-12 19:27:55,141 INFO  User solution successfully verified
2019-03-12 19:27:55,142 INFO  Processing the response from verify service
2019-03-12 19:27:55,144 INFO  Starting to parse JSON response
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,146 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:27:55,148 INFO  Successfully parsed JSON response
2019-03-12 19:27:55,149 INFO  In the process of generating verify response in HTML
2019-03-12 19:27:55,223 INFO  Successfully generated verify response in HTML
2019-03-12 19:27:55,223 INFO  Successfully processed the response from service
2019-03-12 19:29:35,708 INFO  Setting request parameters for VerifySolution
2019-03-12 19:29:35,708 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:29:35,708 INFO  Starting to parse the user solution
2019-03-12 19:29:35,709 INFO  Displaying user solution
2019-03-12 19:29:35,760 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        Logistics.__counter+=1\r\n        self.__consumer_id=Logistics.__counter\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:29:35,761 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:29:35,762 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:29:35,762 INFO  Invoking the service to verify the user solution
2019-03-12 19:29:35,762 INFO  Time before invoking service:Tue Mar 12 19:29:35 IST 2019
2019-03-12 19:29:35,763 INFO  Initialising service address for VerifySolution
2019-03-12 19:29:35,763 INFO  Time before invoking service In SUPER:Tue Mar 12 19:29:35 IST 2019
2019-03-12 19:29:37,215 INFO  Time after invoking service In SUPER:Tue Mar 12 19:29:37 IST 2019
2019-03-12 19:29:37,215 INFO  Service responded successfully with required details
2019-03-12 19:29:37,216 INFO  Time after invoking service:Tue Mar 12 19:29:37 IST 2019
2019-03-12 19:29:37,216 INFO  User solution successfully verified
2019-03-12 19:29:37,216 INFO  Processing the response from verify service
2019-03-12 19:29:37,224 INFO  Starting to parse JSON response
2019-03-12 19:29:37,225 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,225 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,225 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,226 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,226 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,226 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,226 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,226 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,226 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,226 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:29:37,227 INFO  Successfully parsed JSON response
2019-03-12 19:29:37,229 INFO  In the process of generating verify response in HTML
2019-03-12 19:29:37,301 INFO  Successfully generated verify response in HTML
2019-03-12 19:29:37,301 INFO  Successfully processed the response from service
2019-03-12 19:30:10,610 INFO  Setting request parameters for VerifySolution
2019-03-12 19:30:10,610 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:30:10,610 INFO  Starting to parse the user solution
2019-03-12 19:30:10,612 INFO  Displaying user solution
2019-03-12 19:30:10,670 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:30:10,671 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:30:10,671 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:30:10,671 INFO  Invoking the service to verify the user solution
2019-03-12 19:30:10,671 INFO  Time before invoking service:Tue Mar 12 19:30:10 IST 2019
2019-03-12 19:30:10,671 INFO  Initialising service address for VerifySolution
2019-03-12 19:30:10,672 INFO  Time before invoking service In SUPER:Tue Mar 12 19:30:10 IST 2019
2019-03-12 19:30:15,123 INFO  Time after invoking service In SUPER:Tue Mar 12 19:30:15 IST 2019
2019-03-12 19:30:15,124 INFO  Service responded successfully with required details
2019-03-12 19:30:15,124 INFO  Time after invoking service:Tue Mar 12 19:30:15 IST 2019
2019-03-12 19:30:15,124 INFO  User solution successfully verified
2019-03-12 19:30:15,125 INFO  Processing the response from verify service
2019-03-12 19:30:15,127 INFO  Starting to parse JSON response
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,128 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,129 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,129 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:30:15,130 INFO  Successfully parsed JSON response
2019-03-12 19:30:15,131 INFO  In the process of generating verify response in HTML
2019-03-12 19:30:15,196 INFO  Successfully generated verify response in HTML
2019-03-12 19:30:15,196 INFO  Successfully processed the response from service
2019-03-12 19:34:25,642 INFO  Setting request parameters for VerifySolution
2019-03-12 19:34:25,643 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:34:25,643 INFO  Starting to parse the user solution
2019-03-12 19:34:25,643 INFO  Displaying user solution
2019-03-12 19:34:25,708 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=7000\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(self.__consumer_id==None):\r\n            Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:34:25,709 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:34:25,710 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:34:25,710 INFO  Invoking the service to verify the user solution
2019-03-12 19:34:25,710 INFO  Time before invoking service:Tue Mar 12 19:34:25 IST 2019
2019-03-12 19:34:25,710 INFO  Initialising service address for VerifySolution
2019-03-12 19:34:25,711 INFO  Time before invoking service In SUPER:Tue Mar 12 19:34:25 IST 2019
2019-03-12 19:34:27,401 INFO  Time after invoking service In SUPER:Tue Mar 12 19:34:27 IST 2019
2019-03-12 19:34:27,401 INFO  Service responded successfully with required details
2019-03-12 19:34:27,401 INFO  Time after invoking service:Tue Mar 12 19:34:27 IST 2019
2019-03-12 19:34:27,401 INFO  User solution successfully verified
2019-03-12 19:34:27,401 INFO  Processing the response from verify service
2019-03-12 19:34:27,408 INFO  Starting to parse JSON response
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,411 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:34:27,413 INFO  Successfully parsed JSON response
2019-03-12 19:34:27,414 INFO  In the process of generating verify response in HTML
2019-03-12 19:34:27,487 INFO  Successfully generated verify response in HTML
2019-03-12 19:34:27,487 INFO  Successfully processed the response from service
2019-03-12 19:36:05,896 INFO  Setting request parameters for VerifySolution
2019-03-12 19:36:05,896 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:36:05,896 INFO  Starting to parse the user solution
2019-03-12 19:36:05,896 INFO  Displaying user solution
2019-03-12 19:36:05,949 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(self.__consumer_id==None):\r\n            Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:36:05,950 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:36:05,950 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:36:05,950 INFO  Invoking the service to verify the user solution
2019-03-12 19:36:05,955 INFO  Time before invoking service:Tue Mar 12 19:36:05 IST 2019
2019-03-12 19:36:05,955 INFO  Initialising service address for VerifySolution
2019-03-12 19:36:05,956 INFO  Time before invoking service In SUPER:Tue Mar 12 19:36:05 IST 2019
2019-03-12 19:36:07,526 INFO  Time after invoking service In SUPER:Tue Mar 12 19:36:07 IST 2019
2019-03-12 19:36:07,526 INFO  Service responded successfully with required details
2019-03-12 19:36:07,527 INFO  Time after invoking service:Tue Mar 12 19:36:07 IST 2019
2019-03-12 19:36:07,527 INFO  User solution successfully verified
2019-03-12 19:36:07,527 INFO  Processing the response from verify service
2019-03-12 19:36:07,529 INFO  Starting to parse JSON response
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,531 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,532 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:36:07,534 INFO  Successfully parsed JSON response
2019-03-12 19:36:07,535 INFO  In the process of generating verify response in HTML
2019-03-12 19:36:07,617 INFO  Successfully generated verify response in HTML
2019-03-12 19:36:07,617 INFO  Successfully processed the response from service
2019-03-12 19:37:29,501 INFO  Setting request parameters for VerifySolution
2019-03-12 19:37:29,501 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:37:29,501 INFO  Starting to parse the user solution
2019-03-12 19:37:29,502 INFO  Displaying user solution
2019-03-12 19:37:29,566 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(self.__consumer_id==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:37:29,567 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:37:29,567 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:37:29,567 INFO  Invoking the service to verify the user solution
2019-03-12 19:37:29,568 INFO  Time before invoking service:Tue Mar 12 19:37:29 IST 2019
2019-03-12 19:37:29,568 INFO  Initialising service address for VerifySolution
2019-03-12 19:37:29,568 INFO  Time before invoking service In SUPER:Tue Mar 12 19:37:29 IST 2019
2019-03-12 19:37:31,132 INFO  Time after invoking service In SUPER:Tue Mar 12 19:37:31 IST 2019
2019-03-12 19:37:31,133 INFO  Service responded successfully with required details
2019-03-12 19:37:31,133 INFO  Time after invoking service:Tue Mar 12 19:37:31 IST 2019
2019-03-12 19:37:31,133 INFO  User solution successfully verified
2019-03-12 19:37:31,134 INFO  Processing the response from verify service
2019-03-12 19:37:31,136 INFO  Starting to parse JSON response
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,138 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:37:31,139 INFO  Successfully parsed JSON response
2019-03-12 19:37:31,140 INFO  In the process of generating verify response in HTML
2019-03-12 19:37:31,214 INFO  Successfully generated verify response in HTML
2019-03-12 19:37:31,215 INFO  Successfully processed the response from service
2019-03-12 19:38:00,670 INFO  Setting request parameters for VerifySolution
2019-03-12 19:38:00,670 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:38:00,670 INFO  Starting to parse the user solution
2019-03-12 19:38:00,671 INFO  Displaying user solution
2019-03-12 19:38:00,735 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7001\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:38:00,736 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:38:00,737 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:38:00,737 INFO  Invoking the service to verify the user solution
2019-03-12 19:38:00,737 INFO  Time before invoking service:Tue Mar 12 19:38:00 IST 2019
2019-03-12 19:38:00,737 INFO  Initialising service address for VerifySolution
2019-03-12 19:38:00,738 INFO  Time before invoking service In SUPER:Tue Mar 12 19:38:00 IST 2019
2019-03-12 19:38:02,231 INFO  Time after invoking service In SUPER:Tue Mar 12 19:38:02 IST 2019
2019-03-12 19:38:02,232 INFO  Service responded successfully with required details
2019-03-12 19:38:02,232 INFO  Time after invoking service:Tue Mar 12 19:38:02 IST 2019
2019-03-12 19:38:02,232 INFO  User solution successfully verified
2019-03-12 19:38:02,233 INFO  Processing the response from verify service
2019-03-12 19:38:02,239 INFO  Starting to parse JSON response
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,242 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:02,244 INFO  Successfully parsed JSON response
2019-03-12 19:38:02,245 INFO  In the process of generating verify response in HTML
2019-03-12 19:38:02,318 INFO  Successfully generated verify response in HTML
2019-03-12 19:38:02,318 INFO  Successfully processed the response from service
2019-03-12 19:38:22,357 INFO  Setting request parameters for VerifySolution
2019-03-12 19:38:22,357 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:38:22,357 INFO  Starting to parse the user solution
2019-03-12 19:38:22,358 INFO  Displaying user solution
2019-03-12 19:38:22,415 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:38:22,416 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:38:22,416 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:38:22,416 INFO  Invoking the service to verify the user solution
2019-03-12 19:38:22,417 INFO  Time before invoking service:Tue Mar 12 19:38:22 IST 2019
2019-03-12 19:38:22,417 INFO  Initialising service address for VerifySolution
2019-03-12 19:38:22,417 INFO  Time before invoking service In SUPER:Tue Mar 12 19:38:22 IST 2019
2019-03-12 19:38:23,936 INFO  Time after invoking service In SUPER:Tue Mar 12 19:38:23 IST 2019
2019-03-12 19:38:23,936 INFO  Service responded successfully with required details
2019-03-12 19:38:23,937 INFO  Time after invoking service:Tue Mar 12 19:38:23 IST 2019
2019-03-12 19:38:23,937 INFO  User solution successfully verified
2019-03-12 19:38:23,937 INFO  Processing the response from verify service
2019-03-12 19:38:23,939 INFO  Starting to parse JSON response
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,941 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:38:23,942 INFO  Successfully parsed JSON response
2019-03-12 19:38:23,945 INFO  In the process of generating verify response in HTML
2019-03-12 19:38:24,025 INFO  Successfully generated verify response in HTML
2019-03-12 19:38:24,026 INFO  Successfully processed the response from service
2019-03-12 19:40:13,296 INFO  Setting request parameters for VerifySolution
2019-03-12 19:40:13,296 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:40:13,296 INFO  Starting to parse the user solution
2019-03-12 19:40:13,297 INFO  Displaying user solution
2019-03-12 19:40:13,351 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:40:13,351 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:40:13,351 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:40:13,351 INFO  Invoking the service to verify the user solution
2019-03-12 19:40:13,352 INFO  Time before invoking service:Tue Mar 12 19:40:13 IST 2019
2019-03-12 19:40:13,352 INFO  Initialising service address for VerifySolution
2019-03-12 19:40:13,352 INFO  Time before invoking service In SUPER:Tue Mar 12 19:40:13 IST 2019
2019-03-12 19:40:14,945 INFO  Time after invoking service In SUPER:Tue Mar 12 19:40:14 IST 2019
2019-03-12 19:40:14,946 INFO  Service responded successfully with required details
2019-03-12 19:40:14,946 INFO  Time after invoking service:Tue Mar 12 19:40:14 IST 2019
2019-03-12 19:40:14,946 INFO  User solution successfully verified
2019-03-12 19:40:14,946 INFO  Processing the response from verify service
2019-03-12 19:40:14,950 INFO  Starting to parse JSON response
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,952 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:40:14,953 INFO  Successfully parsed JSON response
2019-03-12 19:40:14,955 INFO  In the process of generating verify response in HTML
2019-03-12 19:40:15,044 INFO  Successfully generated verify response in HTML
2019-03-12 19:40:15,044 INFO  Successfully processed the response from service
2019-03-12 19:42:28,495 INFO  Setting request parameters for VerifySolution
2019-03-12 19:42:28,495 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:42:28,495 INFO  Starting to parse the user solution
2019-03-12 19:42:28,496 INFO  Displaying user solution
2019-03-12 19:42:28,560 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()):\r\n            if(self.validate_meter_reading()):\r\n                self.generate_consumer_id()\r\n                total_distance=self.get_end_reading()-self.get_start_reading()\r\n                if(self.__goods_weight<=1000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n                else:\r\n                    charge_per_kilometer=200\r\n                bill_amount=total_distance*charge_per_kilometer\r\n                bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n                return bill_amount\r\n            else:\r\n                return -1\r\n        else:\r\n            return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:42:28,560 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:42:28,561 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:42:28,561 INFO  Invoking the service to verify the user solution
2019-03-12 19:42:28,561 INFO  Time before invoking service:Tue Mar 12 19:42:28 IST 2019
2019-03-12 19:42:28,561 INFO  Initialising service address for VerifySolution
2019-03-12 19:42:28,562 INFO  Time before invoking service In SUPER:Tue Mar 12 19:42:28 IST 2019
2019-03-12 19:42:30,195 INFO  Time after invoking service In SUPER:Tue Mar 12 19:42:30 IST 2019
2019-03-12 19:42:30,195 INFO  Service responded successfully with required details
2019-03-12 19:42:30,195 INFO  Time after invoking service:Tue Mar 12 19:42:30 IST 2019
2019-03-12 19:42:30,195 INFO  User solution successfully verified
2019-03-12 19:42:30,196 INFO  Processing the response from verify service
2019-03-12 19:42:30,198 INFO  Starting to parse JSON response
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,200 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,201 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,201 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:42:30,203 INFO  Successfully parsed JSON response
2019-03-12 19:42:30,204 INFO  In the process of generating verify response in HTML
2019-03-12 19:42:30,275 INFO  Successfully generated verify response in HTML
2019-03-12 19:42:30,275 INFO  Successfully processed the response from service
2019-03-12 19:44:57,588 INFO  Setting request parameters for VerifySolution
2019-03-12 19:44:57,589 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:44:57,589 INFO  Starting to parse the user solution
2019-03-12 19:44:57,589 INFO  Displaying user solution
2019-03-12 19:44:57,638 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if self.validate_carrier_type() and self.validate_meter_reading():\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=self.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:44:57,638 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:44:57,639 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:44:57,639 INFO  Invoking the service to verify the user solution
2019-03-12 19:44:57,639 INFO  Time before invoking service:Tue Mar 12 19:44:57 IST 2019
2019-03-12 19:44:57,639 INFO  Initialising service address for VerifySolution
2019-03-12 19:44:57,640 INFO  Time before invoking service In SUPER:Tue Mar 12 19:44:57 IST 2019
2019-03-12 19:44:59,080 INFO  Time after invoking service In SUPER:Tue Mar 12 19:44:59 IST 2019
2019-03-12 19:44:59,080 INFO  Service responded successfully with required details
2019-03-12 19:44:59,081 INFO  Time after invoking service:Tue Mar 12 19:44:59 IST 2019
2019-03-12 19:44:59,081 INFO  User solution successfully verified
2019-03-12 19:44:59,081 INFO  Processing the response from verify service
2019-03-12 19:44:59,084 INFO  Starting to parse JSON response
2019-03-12 19:44:59,085 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,086 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:44:59,087 INFO  Successfully parsed JSON response
2019-03-12 19:44:59,088 INFO  In the process of generating verify response in HTML
2019-03-12 19:44:59,162 INFO  Successfully generated verify response in HTML
2019-03-12 19:44:59,162 INFO  Successfully processed the response from service
2019-03-12 19:46:18,599 INFO  Setting request parameters for VerifySolution
2019-03-12 19:46:18,599 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:46:18,599 INFO  Starting to parse the user solution
2019-03-12 19:46:18,600 INFO  Displaying user solution
2019-03-12 19:46:18,650 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()!=-1):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=self.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:46:18,650 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:46:18,651 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:46:18,651 INFO  Invoking the service to verify the user solution
2019-03-12 19:46:18,652 INFO  Time before invoking service:Tue Mar 12 19:46:18 IST 2019
2019-03-12 19:46:18,652 INFO  Initialising service address for VerifySolution
2019-03-12 19:46:18,653 INFO  Time before invoking service In SUPER:Tue Mar 12 19:46:18 IST 2019
2019-03-12 19:46:20,075 INFO  Time after invoking service In SUPER:Tue Mar 12 19:46:20 IST 2019
2019-03-12 19:46:20,075 INFO  Service responded successfully with required details
2019-03-12 19:46:20,075 INFO  Time after invoking service:Tue Mar 12 19:46:20 IST 2019
2019-03-12 19:46:20,075 INFO  User solution successfully verified
2019-03-12 19:46:20,076 INFO  Processing the response from verify service
2019-03-12 19:46:20,082 INFO  Starting to parse JSON response
2019-03-12 19:46:20,084 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:20,084 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:20,084 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:20,084 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:20,084 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:20,084 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:20,084 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:20,086 INFO  Successfully parsed JSON response
2019-03-12 19:46:20,087 INFO  In the process of generating verify response in HTML
2019-03-12 19:46:20,166 INFO  Successfully generated verify response in HTML
2019-03-12 19:46:20,167 INFO  Successfully processed the response from service
2019-03-12 19:46:41,425 INFO  Setting request parameters for VerifySolution
2019-03-12 19:46:41,426 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:46:41,426 INFO  Starting to parse the user solution
2019-03-12 19:46:41,427 INFO  Displaying user solution
2019-03-12 19:46:41,495 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type() and self.validate_meter_reading()!=-1):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=self.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:46:41,496 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:46:41,496 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:46:41,496 INFO  Invoking the service to verify the user solution
2019-03-12 19:46:41,496 INFO  Time before invoking service:Tue Mar 12 19:46:41 IST 2019
2019-03-12 19:46:41,496 INFO  Initialising service address for VerifySolution
2019-03-12 19:46:41,497 INFO  Time before invoking service In SUPER:Tue Mar 12 19:46:41 IST 2019
2019-03-12 19:46:43,041 INFO  Time after invoking service In SUPER:Tue Mar 12 19:46:43 IST 2019
2019-03-12 19:46:43,041 INFO  Service responded successfully with required details
2019-03-12 19:46:43,041 INFO  Time after invoking service:Tue Mar 12 19:46:43 IST 2019
2019-03-12 19:46:43,041 INFO  User solution successfully verified
2019-03-12 19:46:43,042 INFO  Processing the response from verify service
2019-03-12 19:46:43,044 INFO  Starting to parse JSON response
2019-03-12 19:46:43,045 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:43,045 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:43,045 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:43,045 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:43,045 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:43,045 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:43,045 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:43,047 INFO  Successfully parsed JSON response
2019-03-12 19:46:43,047 INFO  In the process of generating verify response in HTML
2019-03-12 19:46:43,117 INFO  Successfully generated verify response in HTML
2019-03-12 19:46:43,117 INFO  Successfully processed the response from service
2019-03-12 19:46:53,088 INFO  Setting request parameters for VerifySolution
2019-03-12 19:46:53,088 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:46:53,088 INFO  Starting to parse the user solution
2019-03-12 19:46:53,089 INFO  Displaying user solution
2019-03-12 19:46:53,147 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=self.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:46:53,148 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:46:53,148 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:46:53,148 INFO  Invoking the service to verify the user solution
2019-03-12 19:46:53,148 INFO  Time before invoking service:Tue Mar 12 19:46:53 IST 2019
2019-03-12 19:46:53,148 INFO  Initialising service address for VerifySolution
2019-03-12 19:46:53,149 INFO  Time before invoking service In SUPER:Tue Mar 12 19:46:53 IST 2019
2019-03-12 19:46:54,637 INFO  Time after invoking service In SUPER:Tue Mar 12 19:46:54 IST 2019
2019-03-12 19:46:54,637 INFO  Service responded successfully with required details
2019-03-12 19:46:54,638 INFO  Time after invoking service:Tue Mar 12 19:46:54 IST 2019
2019-03-12 19:46:54,638 INFO  User solution successfully verified
2019-03-12 19:46:54,638 INFO  Processing the response from verify service
2019-03-12 19:46:54,640 INFO  Starting to parse JSON response
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,642 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:46:54,644 INFO  Successfully parsed JSON response
2019-03-12 19:46:54,645 INFO  In the process of generating verify response in HTML
2019-03-12 19:46:54,717 INFO  Successfully generated verify response in HTML
2019-03-12 19:46:54,717 INFO  Successfully processed the response from service
2019-03-12 19:47:06,102 INFO  Setting request parameters for VerifySolution
2019-03-12 19:47:06,102 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:47:06,102 INFO  Starting to parse the user solution
2019-03-12 19:47:06,102 INFO  Displaying user solution
2019-03-12 19:47:06,157 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=self.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:47:06,158 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:47:06,158 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:47:06,158 INFO  Invoking the service to verify the user solution
2019-03-12 19:47:06,159 INFO  Time before invoking service:Tue Mar 12 19:47:06 IST 2019
2019-03-12 19:47:06,159 INFO  Initialising service address for VerifySolution
2019-03-12 19:47:06,159 INFO  Time before invoking service In SUPER:Tue Mar 12 19:47:06 IST 2019
2019-03-12 19:47:07,612 INFO  Time after invoking service In SUPER:Tue Mar 12 19:47:07 IST 2019
2019-03-12 19:47:07,612 INFO  Service responded successfully with required details
2019-03-12 19:47:07,613 INFO  Time after invoking service:Tue Mar 12 19:47:07 IST 2019
2019-03-12 19:47:07,613 INFO  User solution successfully verified
2019-03-12 19:47:07,613 INFO  Processing the response from verify service
2019-03-12 19:47:07,616 INFO  Starting to parse JSON response
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,617 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:47:07,619 INFO  Successfully parsed JSON response
2019-03-12 19:47:07,620 INFO  In the process of generating verify response in HTML
2019-03-12 19:47:07,732 INFO  Successfully generated verify response in HTML
2019-03-12 19:47:07,732 INFO  Successfully processed the response from service
2019-03-12 19:48:01,870 INFO  Setting request parameters for VerifySolution
2019-03-12 19:48:01,870 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:48:01,870 INFO  Starting to parse the user solution
2019-03-12 19:48:01,871 INFO  Displaying user solution
2019-03-12 19:48:01,925 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter==None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=self.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:48:01,925 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:48:01,925 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:48:01,926 INFO  Invoking the service to verify the user solution
2019-03-12 19:48:01,926 INFO  Time before invoking service:Tue Mar 12 19:48:01 IST 2019
2019-03-12 19:48:01,926 INFO  Initialising service address for VerifySolution
2019-03-12 19:48:01,926 INFO  Time before invoking service In SUPER:Tue Mar 12 19:48:01 IST 2019
2019-03-12 19:48:03,436 INFO  Time after invoking service In SUPER:Tue Mar 12 19:48:03 IST 2019
2019-03-12 19:48:03,436 INFO  Service responded successfully with required details
2019-03-12 19:48:03,436 INFO  Time after invoking service:Tue Mar 12 19:48:03 IST 2019
2019-03-12 19:48:03,436 INFO  User solution successfully verified
2019-03-12 19:48:03,437 INFO  Processing the response from verify service
2019-03-12 19:48:03,439 INFO  Starting to parse JSON response
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,440 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:03,441 INFO  Successfully parsed JSON response
2019-03-12 19:48:03,442 INFO  In the process of generating verify response in HTML
2019-03-12 19:48:03,522 INFO  Successfully generated verify response in HTML
2019-03-12 19:48:03,522 INFO  Successfully processed the response from service
2019-03-12 19:48:37,512 INFO  Setting request parameters for VerifySolution
2019-03-12 19:48:37,512 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:48:37,512 INFO  Starting to parse the user solution
2019-03-12 19:48:37,512 INFO  Displaying user solution
2019-03-12 19:48:37,569 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=self.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:48:37,569 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:48:37,569 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:48:37,569 INFO  Invoking the service to verify the user solution
2019-03-12 19:48:37,570 INFO  Time before invoking service:Tue Mar 12 19:48:37 IST 2019
2019-03-12 19:48:37,570 INFO  Initialising service address for VerifySolution
2019-03-12 19:48:37,570 INFO  Time before invoking service In SUPER:Tue Mar 12 19:48:37 IST 2019
2019-03-12 19:48:39,265 INFO  Time after invoking service In SUPER:Tue Mar 12 19:48:39 IST 2019
2019-03-12 19:48:39,265 INFO  Service responded successfully with required details
2019-03-12 19:48:39,266 INFO  Time after invoking service:Tue Mar 12 19:48:39 IST 2019
2019-03-12 19:48:39,266 INFO  User solution successfully verified
2019-03-12 19:48:39,266 INFO  Processing the response from verify service
2019-03-12 19:48:39,268 INFO  Starting to parse JSON response
2019-03-12 19:48:39,270 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,270 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,270 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,270 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,270 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,270 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,270 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,271 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,271 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,271 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:48:39,273 INFO  Successfully parsed JSON response
2019-03-12 19:48:39,274 INFO  In the process of generating verify response in HTML
2019-03-12 19:48:39,354 INFO  Successfully generated verify response in HTML
2019-03-12 19:48:39,354 INFO  Successfully processed the response from service
2019-03-12 19:49:54,029 INFO  Setting request parameters for VerifySolution
2019-03-12 19:49:54,029 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:49:54,029 INFO  Starting to parse the user solution
2019-03-12 19:49:54,029 INFO  Displaying user solution
2019-03-12 19:49:54,089 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id # implement the code to generate the consumer id\r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000] #these lists are storing vehicle type, minimum charge, rate per kilometer for first hundred and rate per kilometer for rest of distance\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:49:54,090 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:49:54,091 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:49:54,091 INFO  Invoking the service to verify the user solution
2019-03-12 19:49:54,091 INFO  Time before invoking service:Tue Mar 12 19:49:54 IST 2019
2019-03-12 19:49:54,092 INFO  Initialising service address for VerifySolution
2019-03-12 19:49:54,092 INFO  Time before invoking service In SUPER:Tue Mar 12 19:49:54 IST 2019
2019-03-12 19:49:55,616 INFO  Time after invoking service In SUPER:Tue Mar 12 19:49:55 IST 2019
2019-03-12 19:49:55,617 INFO  Service responded successfully with required details
2019-03-12 19:49:55,617 INFO  Time after invoking service:Tue Mar 12 19:49:55 IST 2019
2019-03-12 19:49:55,617 INFO  User solution successfully verified
2019-03-12 19:49:55,617 INFO  Processing the response from verify service
2019-03-12 19:49:55,625 INFO  Starting to parse JSON response
2019-03-12 19:49:55,627 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,627 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,627 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,628 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,628 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,628 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,628 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,628 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,628 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,628 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:49:55,630 INFO  Successfully parsed JSON response
2019-03-12 19:49:55,632 INFO  In the process of generating verify response in HTML
2019-03-12 19:49:55,729 INFO  Successfully generated verify response in HTML
2019-03-12 19:49:55,729 INFO  Successfully processed the response from service
2019-03-12 19:51:00,094 INFO  Setting request parameters for VerifySolution
2019-03-12 19:51:00,094 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:51:00,094 INFO  Starting to parse the user solution
2019-03-12 19:51:00,095 INFO  Displaying user solution
2019-03-12 19:51:00,167 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:51:00,168 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:51:00,168 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:51:00,169 INFO  Invoking the service to verify the user solution
2019-03-12 19:51:00,169 INFO  Time before invoking service:Tue Mar 12 19:51:00 IST 2019
2019-03-12 19:51:00,169 INFO  Initialising service address for VerifySolution
2019-03-12 19:51:00,170 INFO  Time before invoking service In SUPER:Tue Mar 12 19:51:00 IST 2019
2019-03-12 19:51:01,657 INFO  Time after invoking service In SUPER:Tue Mar 12 19:51:01 IST 2019
2019-03-12 19:51:01,658 INFO  Service responded successfully with required details
2019-03-12 19:51:01,659 INFO  Time after invoking service:Tue Mar 12 19:51:01 IST 2019
2019-03-12 19:51:01,659 INFO  User solution successfully verified
2019-03-12 19:51:01,660 INFO  Processing the response from verify service
2019-03-12 19:51:01,663 INFO  Starting to parse JSON response
2019-03-12 19:51:01,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,665 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,665 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,665 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,665 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,665 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,665 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,665 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:01,666 INFO  Successfully parsed JSON response
2019-03-12 19:51:01,668 INFO  In the process of generating verify response in HTML
2019-03-12 19:51:01,752 INFO  Successfully generated verify response in HTML
2019-03-12 19:51:01,753 INFO  Successfully processed the response from service
2019-03-12 19:51:17,820 INFO  Setting request parameters for VerifySolution
2019-03-12 19:51:17,820 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:51:17,820 INFO  Starting to parse the user solution
2019-03-12 19:51:17,821 INFO  Displaying user solution
2019-03-12 19:51:17,873 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()#PassengerLogistics.__list_vehicle [self.validate_vehicle_type()]\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:51:17,874 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:51:17,874 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:51:17,874 INFO  Invoking the service to verify the user solution
2019-03-12 19:51:17,874 INFO  Time before invoking service:Tue Mar 12 19:51:17 IST 2019
2019-03-12 19:51:17,874 INFO  Initialising service address for VerifySolution
2019-03-12 19:51:17,875 INFO  Time before invoking service In SUPER:Tue Mar 12 19:51:17 IST 2019
2019-03-12 19:51:19,428 INFO  Time after invoking service In SUPER:Tue Mar 12 19:51:19 IST 2019
2019-03-12 19:51:19,429 INFO  Service responded successfully with required details
2019-03-12 19:51:19,429 INFO  Time after invoking service:Tue Mar 12 19:51:19 IST 2019
2019-03-12 19:51:19,429 INFO  User solution successfully verified
2019-03-12 19:51:19,430 INFO  Processing the response from verify service
2019-03-12 19:51:19,432 INFO  Starting to parse JSON response
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,434 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:19,436 INFO  Successfully parsed JSON response
2019-03-12 19:51:19,437 INFO  In the process of generating verify response in HTML
2019-03-12 19:51:19,513 INFO  Successfully generated verify response in HTML
2019-03-12 19:51:19,513 INFO  Successfully processed the response from service
2019-03-12 19:51:40,407 INFO  Setting request parameters for VerifySolution
2019-03-12 19:51:40,407 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:51:40,407 INFO  Starting to parse the user solution
2019-03-12 19:51:40,411 INFO  Displaying user solution
2019-03-12 19:51:40,468 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*100)+((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx])\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:51:40,468 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:51:40,468 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:51:40,468 INFO  Invoking the service to verify the user solution
2019-03-12 19:51:40,468 INFO  Time before invoking service:Tue Mar 12 19:51:40 IST 2019
2019-03-12 19:51:40,468 INFO  Initialising service address for VerifySolution
2019-03-12 19:51:40,469 INFO  Time before invoking service In SUPER:Tue Mar 12 19:51:40 IST 2019
2019-03-12 19:51:42,070 INFO  Time after invoking service In SUPER:Tue Mar 12 19:51:42 IST 2019
2019-03-12 19:51:42,071 INFO  Service responded successfully with required details
2019-03-12 19:51:42,071 INFO  Time after invoking service:Tue Mar 12 19:51:42 IST 2019
2019-03-12 19:51:42,071 INFO  User solution successfully verified
2019-03-12 19:51:42,072 INFO  Processing the response from verify service
2019-03-12 19:51:42,075 INFO  Starting to parse JSON response
2019-03-12 19:51:42,078 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,078 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,078 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,078 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,079 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,079 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,079 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,079 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,079 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,079 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:51:42,082 INFO  Successfully parsed JSON response
2019-03-12 19:51:42,084 INFO  In the process of generating verify response in HTML
2019-03-12 19:51:42,172 INFO  Successfully generated verify response in HTML
2019-03-12 19:51:42,172 INFO  Successfully processed the response from service
2019-03-12 19:52:21,301 INFO  Setting request parameters for VerifySolution
2019-03-12 19:52:21,301 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:52:21,301 INFO  Starting to parse the user solution
2019-03-12 19:52:21,302 INFO  Displaying user solution
2019-03-12 19:52:21,357 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge = ((PassengerLogistics.__list_charge_for_hundred[indx]*100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:52:21,360 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:52:21,361 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:52:21,361 INFO  Invoking the service to verify the user solution
2019-03-12 19:52:21,361 INFO  Time before invoking service:Tue Mar 12 19:52:21 IST 2019
2019-03-12 19:52:21,361 INFO  Initialising service address for VerifySolution
2019-03-12 19:52:21,361 INFO  Time before invoking service In SUPER:Tue Mar 12 19:52:21 IST 2019
2019-03-12 19:52:23,045 INFO  Time after invoking service In SUPER:Tue Mar 12 19:52:23 IST 2019
2019-03-12 19:52:23,045 INFO  Service responded successfully with required details
2019-03-12 19:52:23,045 INFO  Time after invoking service:Tue Mar 12 19:52:23 IST 2019
2019-03-12 19:52:23,045 INFO  User solution successfully verified
2019-03-12 19:52:23,046 INFO  Processing the response from verify service
2019-03-12 19:52:23,047 INFO  Starting to parse JSON response
2019-03-12 19:52:23,048 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,049 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:52:23,050 INFO  Successfully parsed JSON response
2019-03-12 19:52:23,051 INFO  In the process of generating verify response in HTML
2019-03-12 19:52:23,117 INFO  Successfully generated verify response in HTML
2019-03-12 19:52:23,118 INFO  Successfully processed the response from service
2019-03-12 19:53:30,852 INFO  Setting request parameters for VerifySolution
2019-03-12 19:53:30,852 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:53:30,852 INFO  Starting to parse the user solution
2019-03-12 19:53:30,853 INFO  Displaying user solution
2019-03-12 19:53:30,921 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge = ((PassengerLogistics.__list_charge_for_hundred[indx]*100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:53:30,922 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:53:30,922 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:53:30,922 INFO  Invoking the service to verify the user solution
2019-03-12 19:53:30,922 INFO  Time before invoking service:Tue Mar 12 19:53:30 IST 2019
2019-03-12 19:53:30,922 INFO  Initialising service address for VerifySolution
2019-03-12 19:53:30,923 INFO  Time before invoking service In SUPER:Tue Mar 12 19:53:30 IST 2019
2019-03-12 19:53:32,471 INFO  Time after invoking service In SUPER:Tue Mar 12 19:53:32 IST 2019
2019-03-12 19:53:32,472 INFO  Service responded successfully with required details
2019-03-12 19:53:32,472 INFO  Time after invoking service:Tue Mar 12 19:53:32 IST 2019
2019-03-12 19:53:32,472 INFO  User solution successfully verified
2019-03-12 19:53:32,473 INFO  Processing the response from verify service
2019-03-12 19:53:32,480 INFO  Starting to parse JSON response
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,482 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:32,483 INFO  Successfully parsed JSON response
2019-03-12 19:53:32,484 INFO  In the process of generating verify response in HTML
2019-03-12 19:53:32,554 INFO  Successfully generated verify response in HTML
2019-03-12 19:53:32,554 INFO  Successfully processed the response from service
2019-03-12 19:53:56,518 INFO  Setting request parameters for VerifySolution
2019-03-12 19:53:56,518 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:53:56,518 INFO  Starting to parse the user solution
2019-03-12 19:53:56,518 INFO  Displaying user solution
2019-03-12 19:53:56,568 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.__list_charge_for_hundred[indx]*100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:53:56,569 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:53:56,569 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:53:56,569 INFO  Invoking the service to verify the user solution
2019-03-12 19:53:56,569 INFO  Time before invoking service:Tue Mar 12 19:53:56 IST 2019
2019-03-12 19:53:56,569 INFO  Initialising service address for VerifySolution
2019-03-12 19:53:56,570 INFO  Time before invoking service In SUPER:Tue Mar 12 19:53:56 IST 2019
2019-03-12 19:53:58,082 INFO  Time after invoking service In SUPER:Tue Mar 12 19:53:58 IST 2019
2019-03-12 19:53:58,083 INFO  Service responded successfully with required details
2019-03-12 19:53:58,083 INFO  Time after invoking service:Tue Mar 12 19:53:58 IST 2019
2019-03-12 19:53:58,083 INFO  User solution successfully verified
2019-03-12 19:53:58,084 INFO  Processing the response from verify service
2019-03-12 19:53:58,086 INFO  Starting to parse JSON response
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,088 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:53:58,089 INFO  Successfully parsed JSON response
2019-03-12 19:53:58,090 INFO  In the process of generating verify response in HTML
2019-03-12 19:53:58,162 INFO  Successfully generated verify response in HTML
2019-03-12 19:53:58,162 INFO  Successfully processed the response from service
2019-03-12 19:54:19,227 INFO  Setting request parameters for VerifySolution
2019-03-12 19:54:19,227 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:54:19,227 INFO  Starting to parse the user solution
2019-03-12 19:54:19,230 INFO  Displaying user solution
2019-03-12 19:54:19,282 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.__list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:54:19,282 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:54:19,282 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:54:19,282 INFO  Invoking the service to verify the user solution
2019-03-12 19:54:19,283 INFO  Time before invoking service:Tue Mar 12 19:54:19 IST 2019
2019-03-12 19:54:19,283 INFO  Initialising service address for VerifySolution
2019-03-12 19:54:19,283 INFO  Time before invoking service In SUPER:Tue Mar 12 19:54:19 IST 2019
2019-03-12 19:54:20,998 INFO  Time after invoking service In SUPER:Tue Mar 12 19:54:20 IST 2019
2019-03-12 19:54:20,998 INFO  Service responded successfully with required details
2019-03-12 19:54:20,998 INFO  Time after invoking service:Tue Mar 12 19:54:20 IST 2019
2019-03-12 19:54:20,998 INFO  User solution successfully verified
2019-03-12 19:54:20,999 INFO  Processing the response from verify service
2019-03-12 19:54:21,001 INFO  Starting to parse JSON response
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,002 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:21,003 INFO  Successfully parsed JSON response
2019-03-12 19:54:21,004 INFO  In the process of generating verify response in HTML
2019-03-12 19:54:21,073 INFO  Successfully generated verify response in HTML
2019-03-12 19:54:21,073 INFO  Successfully processed the response from service
2019-03-12 19:54:33,753 INFO  Setting request parameters for VerifySolution
2019-03-12 19:54:33,753 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:54:33,753 INFO  Starting to parse the user solution
2019-03-12 19:54:33,753 INFO  Displaying user solution
2019-03-12 19:54:33,802 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.__list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:54:33,803 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:54:33,803 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:54:33,803 INFO  Invoking the service to verify the user solution
2019-03-12 19:54:33,804 INFO  Time before invoking service:Tue Mar 12 19:54:33 IST 2019
2019-03-12 19:54:33,804 INFO  Initialising service address for VerifySolution
2019-03-12 19:54:33,804 INFO  Time before invoking service In SUPER:Tue Mar 12 19:54:33 IST 2019
2019-03-12 19:54:35,325 INFO  Time after invoking service In SUPER:Tue Mar 12 19:54:35 IST 2019
2019-03-12 19:54:35,326 INFO  Service responded successfully with required details
2019-03-12 19:54:35,327 INFO  Time after invoking service:Tue Mar 12 19:54:35 IST 2019
2019-03-12 19:54:35,327 INFO  User solution successfully verified
2019-03-12 19:54:35,327 INFO  Processing the response from verify service
2019-03-12 19:54:35,329 INFO  Starting to parse JSON response
2019-03-12 19:54:35,330 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,330 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,330 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,331 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,331 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,331 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,331 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,331 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,331 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,331 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:35,332 INFO  Successfully parsed JSON response
2019-03-12 19:54:35,333 INFO  In the process of generating verify response in HTML
2019-03-12 19:54:35,405 INFO  Successfully generated verify response in HTML
2019-03-12 19:54:35,405 INFO  Successfully processed the response from service
2019-03-12 19:54:55,797 INFO  Setting request parameters for VerifySolution
2019-03-12 19:54:55,797 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:54:55,804 INFO  Starting to parse the user solution
2019-03-12 19:54:55,804 INFO  Displaying user solution
2019-03-12 19:54:55,859 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.__list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:54:55,860 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:54:55,860 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:54:55,860 INFO  Invoking the service to verify the user solution
2019-03-12 19:54:55,861 INFO  Time before invoking service:Tue Mar 12 19:54:55 IST 2019
2019-03-12 19:54:55,861 INFO  Initialising service address for VerifySolution
2019-03-12 19:54:55,861 INFO  Time before invoking service In SUPER:Tue Mar 12 19:54:55 IST 2019
2019-03-12 19:54:57,403 INFO  Time after invoking service In SUPER:Tue Mar 12 19:54:57 IST 2019
2019-03-12 19:54:57,404 INFO  Service responded successfully with required details
2019-03-12 19:54:57,404 INFO  Time after invoking service:Tue Mar 12 19:54:57 IST 2019
2019-03-12 19:54:57,404 INFO  User solution successfully verified
2019-03-12 19:54:57,404 INFO  Processing the response from verify service
2019-03-12 19:54:57,407 INFO  Starting to parse JSON response
2019-03-12 19:54:57,408 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,408 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,408 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,408 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,408 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,408 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,408 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,409 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,409 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,409 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:54:57,410 INFO  Successfully parsed JSON response
2019-03-12 19:54:57,411 INFO  In the process of generating verify response in HTML
2019-03-12 19:54:57,473 INFO  Successfully generated verify response in HTML
2019-03-12 19:54:57,473 INFO  Successfully processed the response from service
2019-03-12 19:55:16,410 INFO  Setting request parameters for VerifySolution
2019-03-12 19:55:16,410 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:55:16,410 INFO  Starting to parse the user solution
2019-03-12 19:55:16,411 INFO  Displaying user solution
2019-03-12 19:55:16,485 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:55:16,485 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:55:16,486 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:55:16,486 INFO  Invoking the service to verify the user solution
2019-03-12 19:55:16,486 INFO  Time before invoking service:Tue Mar 12 19:55:16 IST 2019
2019-03-12 19:55:16,486 INFO  Initialising service address for VerifySolution
2019-03-12 19:55:16,487 INFO  Time before invoking service In SUPER:Tue Mar 12 19:55:16 IST 2019
2019-03-12 19:55:18,049 INFO  Time after invoking service In SUPER:Tue Mar 12 19:55:18 IST 2019
2019-03-12 19:55:18,049 INFO  Service responded successfully with required details
2019-03-12 19:55:18,050 INFO  Time after invoking service:Tue Mar 12 19:55:18 IST 2019
2019-03-12 19:55:18,050 INFO  User solution successfully verified
2019-03-12 19:55:18,051 INFO  Processing the response from verify service
2019-03-12 19:55:18,054 INFO  Starting to parse JSON response
2019-03-12 19:55:18,056 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,056 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,056 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:18,060 INFO  Successfully parsed JSON response
2019-03-12 19:55:18,063 INFO  In the process of generating verify response in HTML
2019-03-12 19:55:18,140 INFO  Successfully generated verify response in HTML
2019-03-12 19:55:18,140 INFO  Successfully processed the response from service
2019-03-12 19:55:28,507 INFO  Setting request parameters for VerifySolution
2019-03-12 19:55:28,507 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:55:28,508 INFO  Starting to parse the user solution
2019-03-12 19:55:28,508 INFO  Displaying user solution
2019-03-12 19:55:28,560 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n         # implement the code to calculate the bill amount according to the requirement\r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} # stores the carrier type and rate per kilometer for 1000kg\r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:55:28,561 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:55:28,561 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:55:28,561 INFO  Invoking the service to verify the user solution
2019-03-12 19:55:28,561 INFO  Time before invoking service:Tue Mar 12 19:55:28 IST 2019
2019-03-12 19:55:28,561 INFO  Initialising service address for VerifySolution
2019-03-12 19:55:28,562 INFO  Time before invoking service In SUPER:Tue Mar 12 19:55:28 IST 2019
2019-03-12 19:55:30,060 INFO  Time after invoking service In SUPER:Tue Mar 12 19:55:30 IST 2019
2019-03-12 19:55:30,061 INFO  Service responded successfully with required details
2019-03-12 19:55:30,061 INFO  Time after invoking service:Tue Mar 12 19:55:30 IST 2019
2019-03-12 19:55:30,062 INFO  User solution successfully verified
2019-03-12 19:55:30,062 INFO  Processing the response from verify service
2019-03-12 19:55:30,066 INFO  Starting to parse JSON response
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,067 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:30,069 INFO  Successfully parsed JSON response
2019-03-12 19:55:30,070 INFO  In the process of generating verify response in HTML
2019-03-12 19:55:30,143 INFO  Successfully generated verify response in HTML
2019-03-12 19:55:30,143 INFO  Successfully processed the response from service
2019-03-12 19:55:55,588 INFO  Setting request parameters for VerifySolution
2019-03-12 19:55:55,590 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:55:55,590 INFO  Starting to parse the user solution
2019-03-12 19:55:55,590 INFO  Displaying user solution
2019-03-12 19:55:55,641 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:55:55,642 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:55:55,642 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:55:55,642 INFO  Invoking the service to verify the user solution
2019-03-12 19:55:55,643 INFO  Time before invoking service:Tue Mar 12 19:55:55 IST 2019
2019-03-12 19:55:55,643 INFO  Initialising service address for VerifySolution
2019-03-12 19:55:55,644 INFO  Time before invoking service In SUPER:Tue Mar 12 19:55:55 IST 2019
2019-03-12 19:55:57,134 INFO  Time after invoking service In SUPER:Tue Mar 12 19:55:57 IST 2019
2019-03-12 19:55:57,134 INFO  Service responded successfully with required details
2019-03-12 19:55:57,135 INFO  Time after invoking service:Tue Mar 12 19:55:57 IST 2019
2019-03-12 19:55:57,136 INFO  User solution successfully verified
2019-03-12 19:55:57,136 INFO  Processing the response from verify service
2019-03-12 19:55:57,141 INFO  Starting to parse JSON response
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,142 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:55:57,143 INFO  Successfully parsed JSON response
2019-03-12 19:55:57,144 INFO  In the process of generating verify response in HTML
2019-03-12 19:55:57,226 INFO  Successfully generated verify response in HTML
2019-03-12 19:55:57,227 INFO  Successfully processed the response from service
2019-03-12 19:56:15,301 INFO  Setting request parameters for VerifySolution
2019-03-12 19:56:15,301 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:56:15,301 INFO  Starting to parse the user solution
2019-03-12 19:56:15,302 INFO  Displaying user solution
2019-03-12 19:56:15,364 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:56:15,365 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:56:15,366 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:56:15,366 INFO  Invoking the service to verify the user solution
2019-03-12 19:56:15,366 INFO  Time before invoking service:Tue Mar 12 19:56:15 IST 2019
2019-03-12 19:56:15,367 INFO  Initialising service address for VerifySolution
2019-03-12 19:56:15,367 INFO  Time before invoking service In SUPER:Tue Mar 12 19:56:15 IST 2019
2019-03-12 19:56:17,140 INFO  Time after invoking service In SUPER:Tue Mar 12 19:56:17 IST 2019
2019-03-12 19:56:17,141 INFO  Service responded successfully with required details
2019-03-12 19:56:17,141 INFO  Time after invoking service:Tue Mar 12 19:56:17 IST 2019
2019-03-12 19:56:17,141 INFO  User solution successfully verified
2019-03-12 19:56:17,142 INFO  Processing the response from verify service
2019-03-12 19:56:17,149 INFO  Starting to parse JSON response
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,151 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:56:17,152 INFO  Successfully parsed JSON response
2019-03-12 19:56:17,153 INFO  In the process of generating verify response in HTML
2019-03-12 19:56:17,233 INFO  Successfully generated verify response in HTML
2019-03-12 19:56:17,233 INFO  Successfully processed the response from service
2019-03-12 19:56:59,139 INFO  Setting request parameters for VerifySolution
2019-03-12 19:56:59,139 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:56:59,139 INFO  Starting to parse the user solution
2019-03-12 19:56:59,140 INFO  Displaying user solution
2019-03-12 19:56:59,182 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type])\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]*2\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:56:59,183 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:56:59,183 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:56:59,183 INFO  Invoking the service to verify the user solution
2019-03-12 19:56:59,183 INFO  Time before invoking service:Tue Mar 12 19:56:59 IST 2019
2019-03-12 19:56:59,183 INFO  Initialising service address for VerifySolution
2019-03-12 19:56:59,184 INFO  Time before invoking service In SUPER:Tue Mar 12 19:56:59 IST 2019
2019-03-12 19:57:00,659 INFO  Time after invoking service In SUPER:Tue Mar 12 19:57:00 IST 2019
2019-03-12 19:57:00,659 INFO  Service responded successfully with required details
2019-03-12 19:57:00,659 INFO  Time after invoking service:Tue Mar 12 19:57:00 IST 2019
2019-03-12 19:57:00,659 INFO  User solution successfully verified
2019-03-12 19:57:00,660 INFO  Processing the response from verify service
2019-03-12 19:57:00,662 INFO  Starting to parse JSON response
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,663 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:00,665 INFO  Successfully parsed JSON response
2019-03-12 19:57:00,666 INFO  In the process of generating verify response in HTML
2019-03-12 19:57:00,736 INFO  Successfully generated verify response in HTML
2019-03-12 19:57:00,736 INFO  Successfully processed the response from service
2019-03-12 19:57:28,036 INFO  Setting request parameters for VerifySolution
2019-03-12 19:57:28,036 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:57:28,036 INFO  Starting to parse the user solution
2019-03-12 19:57:28,036 INFO  Displaying user solution
2019-03-12 19:57:28,091 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type])\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type]*2)\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=GoodsLogistics.__carrier_dict[self.get_carrier_type()]*4\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:57:28,092 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:57:28,092 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:57:28,092 INFO  Invoking the service to verify the user solution
2019-03-12 19:57:28,093 INFO  Time before invoking service:Tue Mar 12 19:57:28 IST 2019
2019-03-12 19:57:28,093 INFO  Initialising service address for VerifySolution
2019-03-12 19:57:28,093 INFO  Time before invoking service In SUPER:Tue Mar 12 19:57:28 IST 2019
2019-03-12 19:57:29,780 INFO  Time after invoking service In SUPER:Tue Mar 12 19:57:29 IST 2019
2019-03-12 19:57:29,781 INFO  Service responded successfully with required details
2019-03-12 19:57:29,781 INFO  Time after invoking service:Tue Mar 12 19:57:29 IST 2019
2019-03-12 19:57:29,781 INFO  User solution successfully verified
2019-03-12 19:57:29,782 INFO  Processing the response from verify service
2019-03-12 19:57:29,785 INFO  Starting to parse JSON response
2019-03-12 19:57:29,787 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,787 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,788 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:29,790 INFO  Successfully parsed JSON response
2019-03-12 19:57:29,791 INFO  In the process of generating verify response in HTML
2019-03-12 19:57:29,871 INFO  Successfully generated verify response in HTML
2019-03-12 19:57:29,871 INFO  Successfully processed the response from service
2019-03-12 19:57:54,336 INFO  Setting request parameters for VerifySolution
2019-03-12 19:57:54,337 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:57:54,337 INFO  Starting to parse the user solution
2019-03-12 19:57:54,339 INFO  Displaying user solution
2019-03-12 19:57:54,407 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type])\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type]*2)\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.get_carrier_type()]*4)\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:57:54,408 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:57:54,408 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:57:54,408 INFO  Invoking the service to verify the user solution
2019-03-12 19:57:54,408 INFO  Time before invoking service:Tue Mar 12 19:57:54 IST 2019
2019-03-12 19:57:54,409 INFO  Initialising service address for VerifySolution
2019-03-12 19:57:54,409 INFO  Time before invoking service In SUPER:Tue Mar 12 19:57:54 IST 2019
2019-03-12 19:57:55,956 INFO  Time after invoking service In SUPER:Tue Mar 12 19:57:55 IST 2019
2019-03-12 19:57:55,957 INFO  Service responded successfully with required details
2019-03-12 19:57:55,957 INFO  Time after invoking service:Tue Mar 12 19:57:55 IST 2019
2019-03-12 19:57:55,957 INFO  User solution successfully verified
2019-03-12 19:57:55,957 INFO  Processing the response from verify service
2019-03-12 19:57:55,959 INFO  Starting to parse JSON response
2019-03-12 19:57:55,960 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,960 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,960 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,960 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,960 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,961 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,961 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,961 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,961 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,961 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:57:55,963 INFO  Successfully parsed JSON response
2019-03-12 19:57:55,964 INFO  In the process of generating verify response in HTML
2019-03-12 19:57:56,036 INFO  Successfully generated verify response in HTML
2019-03-12 19:57:56,037 INFO  Successfully processed the response from service
2019-03-12 19:58:17,839 INFO  Setting request parameters for VerifySolution
2019-03-12 19:58:17,840 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:58:17,840 INFO  Starting to parse the user solution
2019-03-12 19:58:17,841 INFO  Displaying user solution
2019-03-12 19:58:17,903 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n           Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type])\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type]*2)\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.get_carrier_type()]*4)\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:58:17,903 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:58:17,904 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:58:17,904 INFO  Invoking the service to verify the user solution
2019-03-12 19:58:17,904 INFO  Time before invoking service:Tue Mar 12 19:58:17 IST 2019
2019-03-12 19:58:17,904 INFO  Initialising service address for VerifySolution
2019-03-12 19:58:17,905 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:17 IST 2019
2019-03-12 19:58:22,400 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:22 IST 2019
2019-03-12 19:58:22,401 INFO  Service responded successfully with required details
2019-03-12 19:58:22,401 INFO  Time after invoking service:Tue Mar 12 19:58:22 IST 2019
2019-03-12 19:58:22,401 INFO  User solution successfully verified
2019-03-12 19:58:22,401 INFO  Processing the response from verify service
2019-03-12 19:58:22,404 INFO  Starting to parse JSON response
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,405 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:22,406 INFO  Successfully parsed JSON response
2019-03-12 19:58:22,407 INFO  In the process of generating verify response in HTML
2019-03-12 19:58:22,476 INFO  Successfully generated verify response in HTML
2019-03-12 19:58:22,476 INFO  Successfully processed the response from service
2019-03-12 19:58:28,967 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 19:58:28,973 INFO  Displaying user solution
2019-03-12 19:58:28,984 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 19:58:28,984 INFO  Invoking the service to submit the user solution
2019-03-12 19:58:28,984 INFO  Initialising service address for Submit
2019-03-12 19:58:28,985 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:28 IST 2019
2019-03-12 19:58:29,153 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:29 IST 2019
2019-03-12 19:58:29,153 INFO  Service responded successfully with required details
2019-03-12 19:58:29,153 INFO  User solution successfully submitted
2019-03-12 19:58:29,154 INFO  Displaying submission status
2019-03-12 19:58:29,154 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 19:58:31,510 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 19:58:31,511 INFO  Displaying user solution
2019-03-12 19:58:31,520 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 19:58:31,521 INFO  Invoking the service to submit the user solution
2019-03-12 19:58:31,521 INFO  Initialising service address for Submit
2019-03-12 19:58:31,521 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:31 IST 2019
2019-03-12 19:58:31,735 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:31 IST 2019
2019-03-12 19:58:31,735 INFO  Service responded successfully with required details
2019-03-12 19:58:31,735 INFO  User solution successfully submitted
2019-03-12 19:58:31,735 INFO  Displaying submission status
2019-03-12 19:58:31,735 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 19:58:33,598 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 19:58:33,599 INFO  Displaying user solution
2019-03-12 19:58:33,607 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 19:58:33,608 INFO  Invoking the service to submit the user solution
2019-03-12 19:58:33,608 INFO  Initialising service address for Submit
2019-03-12 19:58:33,608 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:33 IST 2019
2019-03-12 19:58:33,658 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:33 IST 2019
2019-03-12 19:58:33,658 INFO  Service responded successfully with required details
2019-03-12 19:58:33,658 INFO  User solution successfully submitted
2019-03-12 19:58:33,658 INFO  Displaying submission status
2019-03-12 19:58:33,658 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 19:58:49,813 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 19:58:49,815 INFO  Displaying user solution
2019-03-12 19:58:49,823 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 19:58:49,823 INFO  Invoking the service to submit the user solution
2019-03-12 19:58:49,823 INFO  Initialising service address for Submit
2019-03-12 19:58:49,823 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:49 IST 2019
2019-03-12 19:58:49,979 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:49 IST 2019
2019-03-12 19:58:49,979 INFO  Service responded successfully with required details
2019-03-12 19:58:49,979 INFO  User solution successfully submitted
2019-03-12 19:58:49,980 INFO  Displaying submission status
2019-03-12 19:58:49,980 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 19:58:52,277 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 19:58:52,278 INFO  Displaying user solution
2019-03-12 19:58:52,286 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 19:58:52,287 INFO  Invoking the service to submit the user solution
2019-03-12 19:58:52,287 INFO  Initialising service address for Submit
2019-03-12 19:58:52,287 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:52 IST 2019
2019-03-12 19:58:52,334 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:52 IST 2019
2019-03-12 19:58:52,334 INFO  Service responded successfully with required details
2019-03-12 19:58:52,334 INFO  User solution successfully submitted
2019-03-12 19:58:52,335 INFO  Displaying submission status
2019-03-12 19:58:52,335 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 19:58:54,135 INFO  Setting request parameters for VerifySolution
2019-03-12 19:58:54,136 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 19:58:54,136 INFO  Starting to parse the user solution
2019-03-12 19:58:54,136 INFO  Displaying user solution
2019-03-12 19:58:54,198 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n            Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type])\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type]*2)\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.get_carrier_type()]*4)\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 19:58:54,198 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 19:58:54,198 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 19:58:54,198 INFO  Invoking the service to verify the user solution
2019-03-12 19:58:54,199 INFO  Time before invoking service:Tue Mar 12 19:58:54 IST 2019
2019-03-12 19:58:54,199 INFO  Initialising service address for VerifySolution
2019-03-12 19:58:54,200 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:54 IST 2019
2019-03-12 19:58:55,620 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:55 IST 2019
2019-03-12 19:58:55,621 INFO  Service responded successfully with required details
2019-03-12 19:58:55,621 INFO  Time after invoking service:Tue Mar 12 19:58:55 IST 2019
2019-03-12 19:58:55,621 INFO  User solution successfully verified
2019-03-12 19:58:55,621 INFO  Processing the response from verify service
2019-03-12 19:58:55,623 INFO  Starting to parse JSON response
2019-03-12 19:58:55,625 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,625 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,625 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,625 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,625 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,625 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,625 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,626 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,626 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,626 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 19:58:55,627 INFO  Successfully parsed JSON response
2019-03-12 19:58:55,628 INFO  In the process of generating verify response in HTML
2019-03-12 19:58:55,694 INFO  Successfully generated verify response in HTML
2019-03-12 19:58:55,694 INFO  Successfully processed the response from service
2019-03-12 19:58:58,781 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 19:58:58,781 INFO  Displaying user solution
2019-03-12 19:58:58,791 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 19:58:58,792 INFO  Invoking the service to submit the user solution
2019-03-12 19:58:58,792 INFO  Initialising service address for Submit
2019-03-12 19:58:58,792 INFO  Time before invoking service In SUPER:Tue Mar 12 19:58:58 IST 2019
2019-03-12 19:58:58,838 INFO  Time after invoking service In SUPER:Tue Mar 12 19:58:58 IST 2019
2019-03-12 19:58:58,838 INFO  Service responded successfully with required details
2019-03-12 19:58:58,838 INFO  User solution successfully submitted
2019-03-12 19:58:58,838 INFO  Displaying submission status
2019-03-12 19:58:58,838 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 20:02:15,121 INFO  Setting request parameters for VerifySolution
2019-03-12 20:02:15,121 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:02:15,121 INFO  Starting to parse the user solution
2019-03-12 20:02:15,122 INFO  Displaying user solution
2019-03-12 20:02:15,200 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-31\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\nfrom abc import ABCMeta, abstractmethod\r\nclass Logistics(metaclass=ABCMeta):\r\n    __counter=None\r\n    def __init__(self,start_reading,end_reading):\r\n        self.__consumer_id=None\r\n        self.__start_reading=start_reading\r\n        self.__end_reading=end_reading\r\n    def get_consumer_id(self):\r\n        return self.__consumer_id\r\n    def get_start_reading(self):\r\n        return self.__start_reading\r\n    def get_end_reading(self):\r\n        return self.__end_reading\r\n    def validate_meter_reading(self):\r\n        if(self.__start_reading >= self.__end_reading):\r\n            return False\r\n        else:\r\n            return True\r\n    def generate_consumer_id(self):\r\n        if(Logistics.__counter is None):\r\n            Logistics.__counter = 7000\r\n        Logistics.__counter = Logistics.__counter+1\r\n        self.__consumer_id = Logistics.__counter\r\n        return self.__consumer_id \r\n    @abstractmethod\r\n    def calculate_bill_amount(self):\r\n        pass\r\nclass PassengerLogistics(Logistics):\r\n    __list_vehicle=[\"BMW\",\"TOYOTA\",\"FORD\"]\r\n    __list_minimum_charge=[3000,1500,1000]\r\n    __list_charge_for_hundred=[30,15,10]   #there is a one to one correspondence\r\n    __list_charge_after_hundred=[25,12,7]\r\n    def __init__(self,vehicle_type,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__vehicle_type=vehicle_type\r\n    def get_vehicle_type(self):\r\n        return self.__vehicle_type\r\n    def validate_vehicle_type(self):\r\n        for index in range(0,len(PassengerLogistics.__list_vehicle)):\r\n            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):\r\n                return index\r\n        return -1\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_vehicle_type()!=-1 and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            distance_travelled = self.get_end_reading()-self.get_start_reading()\r\n            indx = self.validate_vehicle_type()\r\n            if(distance_travelled >= 100):\r\n                travel_charge=((PassengerLogistics.\r\n                                __list_charge_for_hundred[indx]\r\n                                *100)+\r\n                                 ((distance_travelled-100)*PassengerLogistics.\r\n                                  __list_charge_after_hundred[indx]))\r\n            else:\r\n                travel_charge = (PassengerLogistics.\r\n                                 __list_charge_for_hundred[indx]*\r\n                                 distance_travelled)\r\n            if travel_charge < PassengerLogistics.__list_minimum_charge[indx]:\r\n                travel_charge =PassengerLogistics.__list_minimum_charge[indx]\r\n            travel_charge *=1.05\r\n            return travel_charge\r\n        return -1\r\n        \r\nclass GoodsLogistics(Logistics):\r\n    __carrier_dict={\"TATA\":20,\"EICHER\":30,\"FORCE\":35} \r\n    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):\r\n        super().__init__(start_reading,end_reading)\r\n        self.__carrier_type=carrier_type\r\n        self.__goods_weight=goods_weight\r\n    def get_carrier_type(self):\r\n        return self.__carrier_type\r\n    def get_goods_weight(self):\r\n        return self.__goods_weight\r\n    def validate_carrier_type(self):\r\n        for carrier in GoodsLogistics.__carrier_dict:\r\n            if(carrier==self.__carrier_type):\r\n                return True\r\n        return False\r\n    def calculate_bill_amount(self):\r\n        if(self.validate_carrier_type()==True and \r\n           self.validate_meter_reading()==True):\r\n            self.generate_consumer_id()\r\n            total_distance=self.get_end_reading()-self.get_start_reading()\r\n            if(self.__goods_weight<=1000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type])\r\n            elif(self.__goods_weight >1000 and self.__goods_weight<=2000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.__carrier_type]*2)\r\n            elif(self.__goods_weight >2000 and self.__goods_weight<=3000):\r\n                charge_per_kilometer=(GoodsLogistics.\r\n                                      __carrier_dict[self.get_carrier_type()]*4)\r\n            else:\r\n                charge_per_kilometer=200\r\n            bill_amount=total_distance*charge_per_kilometer\r\n            bill_amount=bill_amount+(bill_amount*0.1)+2000\r\n            return bill_amount            \r\n        return -1\r\npassenger_logistic=PassengerLogistics(\"BMW\",300,400)\r\nbill_amount=passenger_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid vehicle type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",passenger_logistic.get_consumer_id())\r\n    print(\"Start reading  :\",passenger_logistic.get_start_reading())\r\n    print(\"End reading    :\",passenger_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\nprint(\"------------------------------------------------------------\")\r\ngoods_logistic=GoodsLogistics(\"FORCE\",3000,300,400)\r\nbill_amount=goods_logistic.calculate_bill_amount()\r\nif(bill_amount==-1):\r\n    print(\"Invalid career type or meter reading \")\r\nelse:\r\n    print(\"Consumer id    :\",goods_logistic.get_consumer_id())\r\n    print(\"Goods weight   :\",goods_logistic.get_goods_weight())\r\n    print(\"Start reading  :\",goods_logistic.get_start_reading())\r\n    print(\"End reading    :\",goods_logistic.get_end_reading())\r\n    print(\"Total Amount   :\",bill_amount)\r\n","asgnmtId":"31","SolutionFileName":"Assign31.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:02:15,201 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:02:15,202 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:02:15,202 INFO  Invoking the service to verify the user solution
2019-03-12 20:02:15,202 INFO  Time before invoking service:Tue Mar 12 20:02:15 IST 2019
2019-03-12 20:02:15,202 INFO  Initialising service address for VerifySolution
2019-03-12 20:02:15,203 INFO  Time before invoking service In SUPER:Tue Mar 12 20:02:15 IST 2019
2019-03-12 20:02:16,795 INFO  Time after invoking service In SUPER:Tue Mar 12 20:02:16 IST 2019
2019-03-12 20:02:16,795 INFO  Service responded successfully with required details
2019-03-12 20:02:16,796 INFO  Time after invoking service:Tue Mar 12 20:02:16 IST 2019
2019-03-12 20:02:16,796 INFO  User solution successfully verified
2019-03-12 20:02:16,797 INFO  Processing the response from verify service
2019-03-12 20:02:16,805 INFO  Starting to parse JSON response
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,808 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:02:16,809 INFO  Successfully parsed JSON response
2019-03-12 20:02:16,810 INFO  In the process of generating verify response in HTML
2019-03-12 20:02:16,905 INFO  Successfully generated verify response in HTML
2019-03-12 20:02:16,905 INFO  Successfully processed the response from service
2019-03-12 20:07:40,746 INFO  Setting request parameters for VerifySolution
2019-03-12 20:07:40,746 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:07:40,746 INFO  Starting to parse the user solution
2019-03-12 20:07:40,747 INFO  Displaying user solution
2019-03-12 20:07:40,825 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-32\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nfrom abc import abstractmethod,ABCMeta\r\nclass Employee(metaclass = ABCMeta):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification):\r\n        self.__job_band=job_band\r\n        self.__employee_name=employee_name\r\n        self.__basic_salary=basic_salary\r\n        self.__qualification=qualification\r\n\r\n    def get_job_band(self):\r\n        return self.__job_band\r\n\r\n    def get_employee_name(self):\r\n        return self.__employee_name\r\n\r\n    def get_basic_salary(self):\r\n        return self.__basic_salary\r\n\r\n    def get_qualification(self):\r\n        return self.__qualification\r\n    @abstractmethod\r\n    def validate_job_band(self):\r\n        pass\r\n\r\n    def validate_basic_salary(self):\r\n        if self.__basic_salary>3000:\r\n            return True\r\n        return False\r\n\r\n    def validate_qualification(self):\r\n        if self.__qualification in [\"Bachelors\", \"Masters\"]:\r\n            return True\r\n        return False\r\n\r\n    @abstractmethod\r\n    def calculate_gross_salary(self):\r\n        pass\r\n    \r\nclass Graduate(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,cgpa):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__cgpa=cgpa\r\n    def get_cgpa(self):\r\n        return self.__cgpa\r\n    def validate_job_band(self):\r\n        if super().get_job_band() in ['A','B','C']:\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and self.validate_qualification() and self.validate_basic_salary()):\r\n            gpa = self.__cgpa\r\n            job_band=super().get_job_band()\r\n            if(4<=gpa<=4.25):\r\n                tpi =1000\r\n            elif(4.26<=gpa<=4.5):\r\n                tpi =1700\r\n            elif(4.51<=gpa<=4.75):\r\n                tpi =3200\r\n            elif(4.76 <=gpa<= 5):\r\n                tpi =5000\r\n            \r\n            if(job_band ==\"A\"):\r\n                incentive  = 0.04\r\n            elif(job_band ==\"B\"):\r\n                incentive  = 0.06\r\n            elif(job_band ==\"C\"):\r\n                incentive  = 0.10\r\n            basic=super().get_basic_salary()\r\n            salary = (basic * incentive)+(basic*0.12)+tpi+basic\r\n            return salary\r\n        return -1\r\n\r\nclass Lateral(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,skill_set):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__skill_set = skill_set\r\n    def get_skill_set(self):\r\n        return self.__skill_set\r\n    def validate_job_band(self):\r\n        if(super().get_job_band() in ['D','E','F']):\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and self.validate_basic_salary() and self.validate_qualification()):\r\n            skill= self.__skill_set\r\n            job_band = super().get_job_band()\r\n            if(job_band ==\"D\"):\r\n                incentive  = 0.13\r\n            elif(job_band ==\"E\"):\r\n                incentive  = 0.16\r\n            elif(job_band ==\"F\"):\r\n                incentive  = 0.20\r\n            if(skill == \"AGP\"):\r\n                sme=6500\r\n            elif(skill == 'AGPT'):\r\n                sme=8200\r\n            elif(skill == \"AGDEV\"):\r\n                sme=11500\r\n            else: \r\n                sme=0\r\n            basic=super().get_basic_salary()\r\n            salary = (basic*1.12) + (basic*incentive) + sme\r\n            return salary\r\n        return -1\r\n","asgnmtId":"32","SolutionFileName":"Assign32.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:07:40,826 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:07:40,827 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:07:40,827 INFO  Invoking the service to verify the user solution
2019-03-12 20:07:40,827 INFO  Time before invoking service:Tue Mar 12 20:07:40 IST 2019
2019-03-12 20:07:40,827 INFO  Initialising service address for VerifySolution
2019-03-12 20:07:40,828 INFO  Time before invoking service In SUPER:Tue Mar 12 20:07:40 IST 2019
2019-03-12 20:07:42,061 INFO  Time after invoking service In SUPER:Tue Mar 12 20:07:42 IST 2019
2019-03-12 20:07:42,061 INFO  Service responded successfully with required details
2019-03-12 20:07:42,062 INFO  Time after invoking service:Tue Mar 12 20:07:42 IST 2019
2019-03-12 20:07:42,062 INFO  User solution successfully verified
2019-03-12 20:07:42,062 INFO  Processing the response from verify service
2019-03-12 20:07:42,069 INFO  Starting to parse JSON response
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,072 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:07:42,073 INFO  Successfully parsed JSON response
2019-03-12 20:07:42,073 INFO  In the process of generating verify response in HTML
2019-03-12 20:07:42,162 INFO  Successfully generated verify response in HTML
2019-03-12 20:07:42,162 INFO  Successfully processed the response from service
2019-03-12 20:08:05,408 INFO  Setting request parameters for VerifySolution
2019-03-12 20:08:05,408 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:08:05,408 INFO  Starting to parse the user solution
2019-03-12 20:08:05,409 INFO  Displaying user solution
2019-03-12 20:08:05,470 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-32\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nfrom abc import abstractmethod,ABCMeta\r\nclass Employee(metaclass = ABCMeta):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification):\r\n        self.__job_band=job_band\r\n        self.__employee_name=employee_name\r\n        self.__basic_salary=basic_salary\r\n        self.__qualification=qualification\r\n\r\n    def get_job_band(self):\r\n        return self.__job_band\r\n\r\n    def get_employee_name(self):\r\n        return self.__employee_name\r\n\r\n    def get_basic_salary(self):\r\n        return self.__basic_salary\r\n\r\n    def get_qualification(self):\r\n        return self.__qualification\r\n    @abstractmethod\r\n    def validate_job_band(self):\r\n        pass\r\n\r\n    def validate_basic_salary(self):\r\n        if self.__basic_salary>3000:\r\n            return True\r\n        return False\r\n\r\n    def validate_qualification(self):\r\n        if self.__qualification in [\"Bachelors\", \"Masters\"]:\r\n            return True\r\n        return False\r\n\r\n    @abstractmethod\r\n    def calculate_gross_salary(self):\r\n        pass\r\n    \r\nclass Graduate(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,cgpa):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__cgpa=cgpa\r\n    def get_cgpa(self):\r\n        return self.__cgpa\r\n    def validate_job_band(self):\r\n        if super().get_job_band() in ['A','B','C']:\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_qualification() and\r\n            self.validate_basic_salary()):\r\n            gpa = self.__cgpa\r\n            job_band=super().get_job_band()\r\n            if(4<=gpa<=4.25):\r\n                tpi =1000\r\n            elif(4.26<=gpa<=4.5):\r\n                tpi =1700\r\n            elif(4.51<=gpa<=4.75):\r\n                tpi =3200\r\n            elif(4.76 <=gpa<= 5):\r\n                tpi =5000\r\n            \r\n            if(job_band ==\"A\"):\r\n                incentive  = 0.04\r\n            elif(job_band ==\"B\"):\r\n                incentive  = 0.06\r\n            elif(job_band ==\"C\"):\r\n                incentive  = 0.10\r\n            basic=super().get_basic_salary()\r\n            salary = (basic * incentive)+(basic*0.12)+tpi+basic\r\n            return salary\r\n        return -1\r\n\r\nclass Lateral(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,skill_set):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__skill_set = skill_set\r\n    def get_skill_set(self):\r\n        return self.__skill_set\r\n    def validate_job_band(self):\r\n        if(super().get_job_band() in ['D','E','F']):\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and self.validate_basic_salary() and self.validate_qualification()):\r\n            skill= self.__skill_set\r\n            job_band = super().get_job_band()\r\n            if(job_band ==\"D\"):\r\n                incentive  = 0.13\r\n            elif(job_band ==\"E\"):\r\n                incentive  = 0.16\r\n            elif(job_band ==\"F\"):\r\n                incentive  = 0.20\r\n            if(skill == \"AGP\"):\r\n                sme=6500\r\n            elif(skill == 'AGPT'):\r\n                sme=8200\r\n            elif(skill == \"AGDEV\"):\r\n                sme=11500\r\n            else: \r\n                sme=0\r\n            basic=super().get_basic_salary()\r\n            salary = (basic*1.12) + (basic*incentive) + sme\r\n            return salary\r\n        return -1\r\n","asgnmtId":"32","SolutionFileName":"Assign32.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:08:05,471 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:08:05,471 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:08:05,471 INFO  Invoking the service to verify the user solution
2019-03-12 20:08:05,471 INFO  Time before invoking service:Tue Mar 12 20:08:05 IST 2019
2019-03-12 20:08:05,471 INFO  Initialising service address for VerifySolution
2019-03-12 20:08:05,472 INFO  Time before invoking service In SUPER:Tue Mar 12 20:08:05 IST 2019
2019-03-12 20:08:06,660 INFO  Time after invoking service In SUPER:Tue Mar 12 20:08:06 IST 2019
2019-03-12 20:08:06,660 INFO  Service responded successfully with required details
2019-03-12 20:08:06,661 INFO  Time after invoking service:Tue Mar 12 20:08:06 IST 2019
2019-03-12 20:08:06,661 INFO  User solution successfully verified
2019-03-12 20:08:06,661 INFO  Processing the response from verify service
2019-03-12 20:08:06,663 INFO  Starting to parse JSON response
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,664 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:06,665 INFO  Successfully parsed JSON response
2019-03-12 20:08:06,666 INFO  In the process of generating verify response in HTML
2019-03-12 20:08:06,739 INFO  Successfully generated verify response in HTML
2019-03-12 20:08:06,739 INFO  Successfully processed the response from service
2019-03-12 20:08:27,462 INFO  Setting request parameters for VerifySolution
2019-03-12 20:08:27,462 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:08:27,462 INFO  Starting to parse the user solution
2019-03-12 20:08:27,462 INFO  Displaying user solution
2019-03-12 20:08:27,519 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-32\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nfrom abc import abstractmethod,ABCMeta\r\nclass Employee(metaclass = ABCMeta):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification):\r\n        self.__job_band=job_band\r\n        self.__employee_name=employee_name\r\n        self.__basic_salary=basic_salary\r\n        self.__qualification=qualification\r\n\r\n    def get_job_band(self):\r\n        return self.__job_band\r\n\r\n    def get_employee_name(self):\r\n        return self.__employee_name\r\n\r\n    def get_basic_salary(self):\r\n        return self.__basic_salary\r\n\r\n    def get_qualification(self):\r\n        return self.__qualification\r\n    @abstractmethod\r\n    def validate_job_band(self):\r\n        pass\r\n\r\n    def validate_basic_salary(self):\r\n        if self.__basic_salary>3000:\r\n            return True\r\n        return False\r\n\r\n    def validate_qualification(self):\r\n        if self.__qualification in [\"Bachelors\", \"Masters\"]:\r\n            return True\r\n        return False\r\n\r\n    @abstractmethod\r\n    def calculate_gross_salary(self):\r\n        pass\r\n    \r\nclass Graduate(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,cgpa):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__cgpa=cgpa\r\n    def get_cgpa(self):\r\n        return self.__cgpa\r\n    def validate_job_band(self):\r\n        if super().get_job_band() in ['A','B','C']:\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_qualification() and\r\n            self.validate_basic_salary()):\r\n            gpa = self.__cgpa\r\n            job_band=super().get_job_band()\r\n            if(4<=gpa<=4.25):\r\n                tpi =1000\r\n            elif(4.26<=gpa<=4.5):\r\n                tpi =1700\r\n            elif(4.51<=gpa<=4.75):\r\n                tpi =3200\r\n            elif(4.76 <=gpa<= 5):\r\n                tpi =5000\r\n            \r\n            if(job_band ==\"A\"):\r\n                incentive  = 0.04\r\n            elif(job_band ==\"B\"):\r\n                incentive  = 0.06\r\n            elif(job_band ==\"C\"):\r\n                incentive  = 0.10\r\n            basic=super().get_basic_salary()\r\n            salary = (basic * incentive)+(basic*0.12)+tpi+basic\r\n            return salary\r\n        return -1\r\n\r\nclass Lateral(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,skill_set):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__skill_set = skill_set\r\n    def get_skill_set(self):\r\n        return self.__skill_set\r\n    def validate_job_band(self):\r\n        if(super().get_job_band() in ['D','E','F']):\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_basic_salary() \r\n           and self.validate_qualification()):\r\n            skill= self.__skill_set\r\n            job_band = super().get_job_band()\r\n            if(job_band ==\"D\"):\r\n                incentive  = 0.13\r\n            elif(job_band ==\"E\"):\r\n                incentive  = 0.16\r\n            elif(job_band ==\"F\"):\r\n                incentive  = 0.20\r\n            if(skill == \"AGP\"):\r\n                sme=6500\r\n            elif(skill == 'AGPT'):\r\n                sme=8200\r\n            elif(skill == \"AGDEV\"):\r\n                sme=11500\r\n            else: \r\n                sme=0\r\n            basic=super().get_basic_salary()\r\n            salary = (basic*1.12) + (basic*incentive) + sme\r\n            return salary\r\n        return -1\r\n","asgnmtId":"32","SolutionFileName":"Assign32.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:08:27,519 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:08:27,520 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:08:27,520 INFO  Invoking the service to verify the user solution
2019-03-12 20:08:27,520 INFO  Time before invoking service:Tue Mar 12 20:08:27 IST 2019
2019-03-12 20:08:27,520 INFO  Initialising service address for VerifySolution
2019-03-12 20:08:27,520 INFO  Time before invoking service In SUPER:Tue Mar 12 20:08:27 IST 2019
2019-03-12 20:08:28,831 INFO  Time after invoking service In SUPER:Tue Mar 12 20:08:28 IST 2019
2019-03-12 20:08:28,831 INFO  Service responded successfully with required details
2019-03-12 20:08:28,831 INFO  Time after invoking service:Tue Mar 12 20:08:28 IST 2019
2019-03-12 20:08:28,832 INFO  User solution successfully verified
2019-03-12 20:08:28,832 INFO  Processing the response from verify service
2019-03-12 20:08:28,834 INFO  Starting to parse JSON response
2019-03-12 20:08:28,835 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,835 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,835 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,835 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,835 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,836 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,836 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,836 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,836 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,836 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:28,837 INFO  Successfully parsed JSON response
2019-03-12 20:08:28,837 INFO  In the process of generating verify response in HTML
2019-03-12 20:08:28,908 INFO  Successfully generated verify response in HTML
2019-03-12 20:08:28,908 INFO  Successfully processed the response from service
2019-03-12 20:08:43,083 INFO  Setting request parameters for VerifySolution
2019-03-12 20:08:43,084 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:08:43,085 INFO  Starting to parse the user solution
2019-03-12 20:08:43,085 INFO  Displaying user solution
2019-03-12 20:08:43,135 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-32\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nfrom abc import abstractmethod,ABCMeta\r\nclass Employee(metaclass = ABCMeta):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification):\r\n        self.__job_band=job_band\r\n        self.__employee_name=employee_name\r\n        self.__basic_salary=basic_salary\r\n        self.__qualification=qualification\r\n\r\n    def get_job_band(self):\r\n        return self.__job_band\r\n\r\n    def get_employee_name(self):\r\n        return self.__employee_name\r\n\r\n    def get_basic_salary(self):\r\n        return self.__basic_salary\r\n\r\n    def get_qualification(self):\r\n        return self.__qualification\r\n    @abstractmethod\r\n    def validate_job_band(self):\r\n        pass\r\n\r\n    def validate_basic_salary(self):\r\n        if self.__basic_salary>3000:\r\n            return True\r\n        return False\r\n\r\n    def validate_qualification(self):\r\n        if self.__qualification in [\"Bachelors\", \"Masters\"]:\r\n            return True\r\n        return False\r\n\r\n    @abstractmethod\r\n    def calculate_gross_salary(self):\r\n        pass\r\n    \r\nclass Graduate(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,cgpa):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__cgpa=cgpa\r\n    def get_cgpa(self):\r\n        return self.__cgpa\r\n    def validate_job_band(self):\r\n        if super().get_job_band() in ['A','B','C']:\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_qualification() and\r\n            self.validate_basic_salary()):\r\n            gpa = self.__cgpa\r\n            job_band=super().get_job_band()\r\n            if(4<=gpa<=4.25):\r\n                tpi =1000\r\n            elif(4.26<=gpa<=4.5):\r\n                tpi =1700\r\n            elif(4.51<=gpa<=4.75):\r\n                tpi =3200\r\n            elif(4.76 <=gpa<= 5):\r\n                tpi =5000\r\n            \r\n            if(job_band ==\"A\"):\r\n                incentive  = 0.04\r\n            elif(job_band ==\"B\"):\r\n                incentive  = 0.06\r\n            elif(job_band ==\"C\"):\r\n                incentive  = 0.10\r\n            basic=super().get_basic_salary()\r\n            salary = (basic * incentive)+(basic*0.12)+tpi+basic\r\n            return salary\r\n        return -1\r\n\r\nclass Lateral(Employee):\r\n    def __init__\r\n    (self,job_band,employee_name,\r\n     basic_salary,qualification,skill_set):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__skill_set = skill_set\r\n    def get_skill_set(self):\r\n        return self.__skill_set\r\n    def validate_job_band(self):\r\n        if(super().get_job_band() in ['D','E','F']):\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_basic_salary() \r\n           and self.validate_qualification()):\r\n            skill= self.__skill_set\r\n            job_band = super().get_job_band()\r\n            if(job_band ==\"D\"):\r\n                incentive  = 0.13\r\n            elif(job_band ==\"E\"):\r\n                incentive  = 0.16\r\n            elif(job_band ==\"F\"):\r\n                incentive  = 0.20\r\n            if(skill == \"AGP\"):\r\n                sme=6500\r\n            elif(skill == 'AGPT'):\r\n                sme=8200\r\n            elif(skill == \"AGDEV\"):\r\n                sme=11500\r\n            else: \r\n                sme=0\r\n            basic=super().get_basic_salary()\r\n            salary = (basic*1.12) + (basic*incentive) + sme\r\n            return salary\r\n        return -1\r\n","asgnmtId":"32","SolutionFileName":"Assign32.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:08:43,135 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:08:43,135 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:08:43,135 INFO  Invoking the service to verify the user solution
2019-03-12 20:08:43,136 INFO  Time before invoking service:Tue Mar 12 20:08:43 IST 2019
2019-03-12 20:08:43,136 INFO  Initialising service address for VerifySolution
2019-03-12 20:08:43,136 INFO  Time before invoking service In SUPER:Tue Mar 12 20:08:43 IST 2019
2019-03-12 20:08:44,354 INFO  Time after invoking service In SUPER:Tue Mar 12 20:08:44 IST 2019
2019-03-12 20:08:44,354 INFO  Service responded successfully with required details
2019-03-12 20:08:44,354 INFO  Time after invoking service:Tue Mar 12 20:08:44 IST 2019
2019-03-12 20:08:44,354 INFO  User solution successfully verified
2019-03-12 20:08:44,355 INFO  Processing the response from verify service
2019-03-12 20:08:44,356 INFO  Starting to parse JSON response
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,357 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,358 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,358 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:44,359 INFO  Successfully parsed JSON response
2019-03-12 20:08:44,359 INFO  In the process of generating verify response in HTML
2019-03-12 20:08:44,474 INFO  Successfully generated verify response in HTML
2019-03-12 20:08:44,474 INFO  Successfully processed the response from service
2019-03-12 20:08:53,608 INFO  Setting request parameters for VerifySolution
2019-03-12 20:08:53,608 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:08:53,608 INFO  Starting to parse the user solution
2019-03-12 20:08:53,609 INFO  Displaying user solution
2019-03-12 20:08:53,657 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-32\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nfrom abc import abstractmethod,ABCMeta\r\nclass Employee(metaclass = ABCMeta):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification):\r\n        self.__job_band=job_band\r\n        self.__employee_name=employee_name\r\n        self.__basic_salary=basic_salary\r\n        self.__qualification=qualification\r\n\r\n    def get_job_band(self):\r\n        return self.__job_band\r\n\r\n    def get_employee_name(self):\r\n        return self.__employee_name\r\n\r\n    def get_basic_salary(self):\r\n        return self.__basic_salary\r\n\r\n    def get_qualification(self):\r\n        return self.__qualification\r\n    @abstractmethod\r\n    def validate_job_band(self):\r\n        pass\r\n\r\n    def validate_basic_salary(self):\r\n        if self.__basic_salary>3000:\r\n            return True\r\n        return False\r\n\r\n    def validate_qualification(self):\r\n        if self.__qualification in [\"Bachelors\", \"Masters\"]:\r\n            return True\r\n        return False\r\n\r\n    @abstractmethod\r\n    def calculate_gross_salary(self):\r\n        pass\r\n    \r\nclass Graduate(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,cgpa):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__cgpa=cgpa\r\n    def get_cgpa(self):\r\n        return self.__cgpa\r\n    def validate_job_band(self):\r\n        if super().get_job_band() in ['A','B','C']:\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_qualification() and\r\n            self.validate_basic_salary()):\r\n            gpa = self.__cgpa\r\n            job_band=super().get_job_band()\r\n            if(4<=gpa<=4.25):\r\n                tpi =1000\r\n            elif(4.26<=gpa<=4.5):\r\n                tpi =1700\r\n            elif(4.51<=gpa<=4.75):\r\n                tpi =3200\r\n            elif(4.76 <=gpa<= 5):\r\n                tpi =5000\r\n            \r\n            if(job_band ==\"A\"):\r\n                incentive  = 0.04\r\n            elif(job_band ==\"B\"):\r\n                incentive  = 0.06\r\n            elif(job_band ==\"C\"):\r\n                incentive  = 0.10\r\n            basic=super().get_basic_salary()\r\n            salary = (basic * incentive)+(basic*0.12)+tpi+basic\r\n            return salary\r\n        return -1\r\n\r\nclass Lateral(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,skill_set):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__skill_set = skill_set\r\n    def get_skill_set(self):\r\n        return self.__skill_set\r\n    def validate_job_band(self):\r\n        if(super().get_job_band() in ['D','E','F']):\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_basic_salary() \r\n           and self.validate_qualification()):\r\n            skill= self.__skill_set\r\n            job_band = super().get_job_band()\r\n            if(job_band ==\"D\"):\r\n                incentive  = 0.13\r\n            elif(job_band ==\"E\"):\r\n                incentive  = 0.16\r\n            elif(job_band ==\"F\"):\r\n                incentive  = 0.20\r\n            if(skill == \"AGP\"):\r\n                sme=6500\r\n            elif(skill == 'AGPT'):\r\n                sme=8200\r\n            elif(skill == \"AGDEV\"):\r\n                sme=11500\r\n            else: \r\n                sme=0\r\n            basic=super().get_basic_salary()\r\n            salary = (basic*1.12) + (basic*incentive) + sme\r\n            return salary\r\n        return -1\r\n","asgnmtId":"32","SolutionFileName":"Assign32.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:08:53,658 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:08:53,658 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:08:53,658 INFO  Invoking the service to verify the user solution
2019-03-12 20:08:53,658 INFO  Time before invoking service:Tue Mar 12 20:08:53 IST 2019
2019-03-12 20:08:53,658 INFO  Initialising service address for VerifySolution
2019-03-12 20:08:53,659 INFO  Time before invoking service In SUPER:Tue Mar 12 20:08:53 IST 2019
2019-03-12 20:08:54,789 INFO  Time after invoking service In SUPER:Tue Mar 12 20:08:54 IST 2019
2019-03-12 20:08:54,789 INFO  Service responded successfully with required details
2019-03-12 20:08:54,789 INFO  Time after invoking service:Tue Mar 12 20:08:54 IST 2019
2019-03-12 20:08:54,790 INFO  User solution successfully verified
2019-03-12 20:08:54,790 INFO  Processing the response from verify service
2019-03-12 20:08:54,791 INFO  Starting to parse JSON response
2019-03-12 20:08:54,792 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,792 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,793 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:08:54,794 INFO  Successfully parsed JSON response
2019-03-12 20:08:54,794 INFO  In the process of generating verify response in HTML
2019-03-12 20:08:54,874 INFO  Successfully generated verify response in HTML
2019-03-12 20:08:54,874 INFO  Successfully processed the response from service
2019-03-12 20:09:07,261 INFO  Setting request parameters for VerifySolution
2019-03-12 20:09:07,262 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:09:07,262 INFO  Starting to parse the user solution
2019-03-12 20:09:07,263 INFO  Displaying user solution
2019-03-12 20:09:07,328 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-32\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nfrom abc import abstractmethod,ABCMeta\r\nclass Employee(metaclass = ABCMeta):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification):\r\n        self.__job_band=job_band\r\n        self.__employee_name=employee_name\r\n        self.__basic_salary=basic_salary\r\n        self.__qualification=qualification\r\n\r\n    def get_job_band(self):\r\n        return self.__job_band\r\n\r\n    def get_employee_name(self):\r\n        return self.__employee_name\r\n\r\n    def get_basic_salary(self):\r\n        return self.__basic_salary\r\n\r\n    def get_qualification(self):\r\n        return self.__qualification\r\n    @abstractmethod\r\n    def validate_job_band(self):\r\n        pass\r\n\r\n    def validate_basic_salary(self):\r\n        if self.__basic_salary>3000:\r\n            return True\r\n        return False\r\n\r\n    def validate_qualification(self):\r\n        if self.__qualification in [\"Bachelors\", \"Masters\"]:\r\n            return True\r\n        return False\r\n\r\n    @abstractmethod\r\n    def calculate_gross_salary(self):\r\n        pass\r\n    \r\nclass Graduate(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,cgpa):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__cgpa=cgpa\r\n    def get_cgpa(self):\r\n        return self.__cgpa\r\n    def validate_job_band(self):\r\n        if super().get_job_band() in ['A','B','C']:\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_qualification() and\r\n            self.validate_basic_salary()):\r\n            gpa = self.__cgpa\r\n            job_band=super().get_job_band()\r\n            if(4<=gpa<=4.25):\r\n                tpi =1000\r\n            elif(4.26<=gpa<=4.5):\r\n                tpi =1700\r\n            elif(4.51<=gpa<=4.75):\r\n                tpi =3200\r\n            elif(4.76 <=gpa<= 5):\r\n                tpi =5000\r\n            \r\n            if(job_band ==\"A\"):\r\n                incentive  = 0.04\r\n            elif(job_band ==\"B\"):\r\n                incentive  = 0.06\r\n            elif(job_band ==\"C\"):\r\n                incentive  = 0.10\r\n            basic=super().get_basic_salary()\r\n            salary = (basic * incentive)+(basic*0.12)+tpi+basic\r\n            return salary\r\n        return -1\r\n\r\nclass Lateral(Employee):\r\n    def __init__(self,job_band,employee_name,\r\n                 basic_salary,qualification,skill_set):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__skill_set = skill_set\r\n    def get_skill_set(self):\r\n        return self.__skill_set\r\n    def validate_job_band(self):\r\n        if(super().get_job_band() in ['D','E','F']):\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_basic_salary() \r\n           and self.validate_qualification()):\r\n            skill= self.__skill_set\r\n            job_band = super().get_job_band()\r\n            if(job_band ==\"D\"):\r\n                incentive  = 0.13\r\n            elif(job_band ==\"E\"):\r\n                incentive  = 0.16\r\n            elif(job_band ==\"F\"):\r\n                incentive  = 0.20\r\n            if(skill == \"AGP\"):\r\n                sme=6500\r\n            elif(skill == 'AGPT'):\r\n                sme=8200\r\n            elif(skill == \"AGDEV\"):\r\n                sme=11500\r\n            else: \r\n                sme=0\r\n            basic=super().get_basic_salary()\r\n            salary = (basic*1.12) + (basic*incentive) + sme\r\n            return salary\r\n        return -1\r\n","asgnmtId":"32","SolutionFileName":"Assign32.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:09:07,328 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:09:07,328 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:09:07,328 INFO  Invoking the service to verify the user solution
2019-03-12 20:09:07,329 INFO  Time before invoking service:Tue Mar 12 20:09:07 IST 2019
2019-03-12 20:09:07,329 INFO  Initialising service address for VerifySolution
2019-03-12 20:09:07,330 INFO  Time before invoking service In SUPER:Tue Mar 12 20:09:07 IST 2019
2019-03-12 20:09:08,608 INFO  Time after invoking service In SUPER:Tue Mar 12 20:09:08 IST 2019
2019-03-12 20:09:08,608 INFO  Service responded successfully with required details
2019-03-12 20:09:08,609 INFO  Time after invoking service:Tue Mar 12 20:09:08 IST 2019
2019-03-12 20:09:08,609 INFO  User solution successfully verified
2019-03-12 20:09:08,609 INFO  Processing the response from verify service
2019-03-12 20:09:08,612 INFO  Starting to parse JSON response
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,613 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:08,614 INFO  Successfully parsed JSON response
2019-03-12 20:09:08,614 INFO  In the process of generating verify response in HTML
2019-03-12 20:09:08,686 INFO  Successfully generated verify response in HTML
2019-03-12 20:09:08,686 INFO  Successfully processed the response from service
2019-03-12 20:09:14,713 INFO  Setting request parameters for VerifySolution
2019-03-12 20:09:14,715 INFO  Initiating to process and prepare Input for the verify service
2019-03-12 20:09:14,716 INFO  Starting to parse the user solution
2019-03-12 20:09:14,719 INFO  Displaying user solution
2019-03-12 20:09:14,815 INFO  Successfully parsed the user solution{"CourseShortName":"OOPR","UserSolution":"#OOPR-Assgn-32\r\n'''\r\nCreated on Mar 12, 2019\r\n\r\n@author: vijay.pal01\r\n'''\r\n\r\n#Start writing your code here\r\nfrom abc import abstractmethod,ABCMeta\r\nclass Employee(metaclass = ABCMeta):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification):\r\n        self.__job_band=job_band\r\n        self.__employee_name=employee_name\r\n        self.__basic_salary=basic_salary\r\n        self.__qualification=qualification\r\n\r\n    def get_job_band(self):\r\n        return self.__job_band\r\n\r\n    def get_employee_name(self):\r\n        return self.__employee_name\r\n\r\n    def get_basic_salary(self):\r\n        return self.__basic_salary\r\n\r\n    def get_qualification(self):\r\n        return self.__qualification\r\n    @abstractmethod\r\n    def validate_job_band(self):\r\n        pass\r\n\r\n    def validate_basic_salary(self):\r\n        if self.__basic_salary>3000:\r\n            return True\r\n        return False\r\n\r\n    def validate_qualification(self):\r\n        if self.__qualification in [\"Bachelors\", \"Masters\"]:\r\n            return True\r\n        return False\r\n\r\n    @abstractmethod\r\n    def calculate_gross_salary(self):\r\n        pass\r\n    \r\nclass Graduate(Employee):\r\n    def __init__(self,job_band,employee_name,basic_salary,qualification,cgpa):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__cgpa=cgpa\r\n    def get_cgpa(self):\r\n        return self.__cgpa\r\n    def validate_job_band(self):\r\n        if super().get_job_band() in ['A','B','C']:\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_qualification() and\r\n            self.validate_basic_salary()):\r\n            gpa = self.__cgpa\r\n            job_band=super().get_job_band()\r\n            if(4<=gpa<=4.25):\r\n                tpi =1000\r\n            elif(4.26<=gpa<=4.5):\r\n                tpi =1700\r\n            elif(4.51<=gpa<=4.75):\r\n                tpi =3200\r\n            elif(4.76 <=gpa<= 5):\r\n                tpi =5000\r\n            \r\n            if(job_band ==\"A\"):\r\n                incentive  = 0.04\r\n            elif(job_band ==\"B\"):\r\n                incentive  = 0.06\r\n            elif(job_band ==\"C\"):\r\n                incentive  = 0.10\r\n            basic=super().get_basic_salary()\r\n            salary = (basic * incentive)+(basic*0.12)+tpi+basic\r\n            return salary\r\n        return -1\r\n\r\nclass Lateral(Employee):\r\n    def __init__(self,job_band,employee_name,\r\n                 basic_salary,qualification,skill_set):\r\n        super().__init__(job_band, employee_name, basic_salary, qualification)\r\n        self.__skill_set = skill_set\r\n    def get_skill_set(self):\r\n        return self.__skill_set\r\n    def validate_job_band(self):\r\n        if(super().get_job_band() in ['D','E','F']):\r\n            return True\r\n        return False\r\n    def calculate_gross_salary(self):\r\n        \r\n        if(self.validate_job_band() and \r\n           self.validate_basic_salary() \r\n           and self.validate_qualification()):\r\n            skill= self.__skill_set\r\n            job_band = super().get_job_band()\r\n            if(job_band ==\"D\"):\r\n                incentive  = 0.13\r\n            elif(job_band ==\"E\"):\r\n                incentive  = 0.16\r\n            elif(job_band ==\"F\"):\r\n                incentive  = 0.20\r\n            if(skill == \"AGP\"):\r\n                sme=6500\r\n            elif(skill == 'AGPT'):\r\n                sme=8200\r\n            elif(skill == \"AGDEV\"):\r\n                sme=11500\r\n            else: \r\n                sme=0\r\n            basic=super().get_basic_salary()\r\n            salary = (basic*1.12) + (basic*incentive) + sme\r\n            return salary\r\n        return -1\r\n","asgnmtId":"32","SolutionFileName":"Assign32.py","AsgnmtTyp":"A","TestcaseFileName":""}
2019-03-12 20:09:14,815 INFO  Successfully processed and prepared the input for the verify service
2019-03-12 20:09:14,815 INFO  Successfully set the request parameters for VerifySolution
2019-03-12 20:09:14,815 INFO  Invoking the service to verify the user solution
2019-03-12 20:09:14,816 INFO  Time before invoking service:Tue Mar 12 20:09:14 IST 2019
2019-03-12 20:09:14,816 INFO  Initialising service address for VerifySolution
2019-03-12 20:09:14,816 INFO  Time before invoking service In SUPER:Tue Mar 12 20:09:14 IST 2019
2019-03-12 20:09:16,051 INFO  Time after invoking service In SUPER:Tue Mar 12 20:09:16 IST 2019
2019-03-12 20:09:16,051 INFO  Service responded successfully with required details
2019-03-12 20:09:16,052 INFO  Time after invoking service:Tue Mar 12 20:09:16 IST 2019
2019-03-12 20:09:16,052 INFO  User solution successfully verified
2019-03-12 20:09:16,053 INFO  Processing the response from verify service
2019-03-12 20:09:16,055 INFO  Starting to parse JSON response
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,057 ERROR Keys used to parse test result JSON might be incorrect
2019-03-12 20:09:16,058 INFO  Successfully parsed JSON response
2019-03-12 20:09:16,059 INFO  In the process of generating verify response in HTML
2019-03-12 20:09:16,127 INFO  Successfully generated verify response in HTML
2019-03-12 20:09:16,127 INFO  Successfully processed the response from service
2019-03-12 20:09:20,058 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 20:09:20,059 INFO  Displaying user solution
2019-03-12 20:09:20,069 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 20:09:20,069 INFO  Invoking the service to submit the user solution
2019-03-12 20:09:20,069 INFO  Initialising service address for Submit
2019-03-12 20:09:20,070 INFO  Time before invoking service In SUPER:Tue Mar 12 20:09:20 IST 2019
2019-03-12 20:09:20,187 INFO  Time after invoking service In SUPER:Tue Mar 12 20:09:20 IST 2019
2019-03-12 20:09:20,187 INFO  Service responded successfully with required details
2019-03-12 20:09:20,187 INFO  User solution successfully submitted
2019-03-12 20:09:20,187 INFO  Displaying submission status
2019-03-12 20:09:20,187 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 20:09:22,657 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 20:09:22,658 INFO  Displaying user solution
2019-03-12 20:09:22,666 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 20:09:22,667 INFO  Invoking the service to submit the user solution
2019-03-12 20:09:22,667 INFO  Initialising service address for Submit
2019-03-12 20:09:22,667 INFO  Time before invoking service In SUPER:Tue Mar 12 20:09:22 IST 2019
2019-03-12 20:09:22,730 INFO  Time after invoking service In SUPER:Tue Mar 12 20:09:22 IST 2019
2019-03-12 20:09:22,730 INFO  Service responded successfully with required details
2019-03-12 20:09:22,730 INFO  User solution successfully submitted
2019-03-12 20:09:22,731 INFO  Displaying submission status
2019-03-12 20:09:22,731 INFO  Displayed submission status successfullySuccessfully Submitted!
2019-03-12 20:09:24,778 INFO  Initiating to process and prepare Input for the submit service
2019-03-12 20:09:24,779 INFO  Displaying user solution
2019-03-12 20:09:24,785 INFO  Successfully processed and prepared the input for the submit service
2019-03-12 20:09:24,786 INFO  Invoking the service to submit the user solution
2019-03-12 20:09:24,786 INFO  Initialising service address for Submit
2019-03-12 20:09:24,786 INFO  Time before invoking service In SUPER:Tue Mar 12 20:09:24 IST 2019
2019-03-12 20:09:24,849 INFO  Time after invoking service In SUPER:Tue Mar 12 20:09:24 IST 2019
2019-03-12 20:09:24,849 INFO  Service responded successfully with required details
2019-03-12 20:09:24,849 INFO  User solution successfully submitted
2019-03-12 20:09:24,850 INFO  Displaying submission status
2019-03-12 20:09:24,850 INFO  Displayed submission status successfullySuccessfully Submitted!
